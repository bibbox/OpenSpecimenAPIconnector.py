<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>OpenSpecimenAPIconnector.os_util.collection_protocol_util API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>OpenSpecimenAPIconnector.os_util.collection_protocol_util</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /bin/python3

from ..os_core.collection_protocol import collection_protocol
from ..os_core.jsons import Json_factory
from ..os_core.url import url_gen

import pandas as pd
import json

class collection_protocol_util:

    &#34;&#34;&#34;Utility class for Site API calls

    This class handles the API calls for OpenSpecimen Collection Protocol. It can create, update, 
    search  and merge  Protocols.
    The output is a JSON dict or the Error message as JSON dict, except the Pandas dataframe.

    Notes
    -----
    In order to use this and also the other classes, the user has to know OpenSpecimen. In the core classes one can
    just pass the parameters via JSON-formatted string. This means the user has to know the keywords.
    The API calls are documented in https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs and 
    the calls refer to this site. More details can be seen in the documentation.

    Example
    -------

    A code example, where the Collection protocols are handled is in the Jupyter-Notebook::

        $ jupyter notebook main.ipynb
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;Constructor of the Class collection_protocol_util

        Constructor of the class colelction_protocol, can handle the basic API-calls
        of the collection protocol in OpenSpecimen. Connects this class to OpenSpecimen
        specific request handle (os_core.request_util.py) and the os_core classes
        Json_fatory, url_gen and collection_protocol

        Parameters
        ----------
        base_url : string
            URL to openspecimen, has the format: http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/ng
        auth : tuple
            Consits of two strings ( loginname , password)
        &#34;&#34;&#34;

        self.jsons = Json_factory()
        self.urls = url_gen()
        self.cps = collection_protocol()

  
    def search_cps(self, searchstring = None, title = None, piid = None, reponame = None, startat = None, maxresults = None, detailedlist = None):

        &#34;&#34;&#34;Search for Colelction Protocols with specific values.

        Search for one or more Collection Protocols with the search_string defined. The search string looks like:
        http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/np/collection-protocols?{param_1}={value_1}&amp;...&amp;{param_x}={value_x}
        With the class collection_protocol_util from os_util and function ::search_cps:: the search string is generated
        and this function is called. Not all keys from OpenSpecimen can be easily searched after.

        Parameters
        ----------
        search_string : string
            openSpecimen&#39;s Advanced Query Language[optional]. Substring of the title or shorttitle

        title : string
            Name of the desired Collection Protocol
        
        ppid : string or int
            Id of the Pricincipal Investigator, gets converted to a string[optional].
        
        reponame : string
            Name of the Repository in which the Collection Protocol is[optional].
        
        startat : int
            Value which one of the outcomes is the first to show, if not specified OpenSpecimen takes 0.
        
        maxresults : int
            Value how many Collection Protocols are shown, if not specified OpenSpecimen takes 100.
        
        detailedList: string
            String in OpenSpecimen&#39;s boolean format, permissable values are true/false. If not specified, OpenSpecimen takes false.

        Returns
        -------
        JSON-dict
            [Details of the matching Collection Protocols, if no one matches it is an empty list.
        &#34;&#34;&#34;

        search_string = self.urls.cp_search_url_gen(searchstring = searchstring, title = title, piid = piid, reponame = reponame,
                                                    startat = startat, maxresults = maxresults, detailedlist = detailedlist)

        r = self.cps.search_collection_protocols(search_string = search_string)

        return r

    def merge_cps(self, src_cp, trg_cp):

        &#34;&#34;&#34;Merge two Collection protocols

        Merge two Colelction Protocols which are defined in src_cp and trg_cp together. To call this function the short titles of
        the source and target collection protocol has to be known. The merged Protocol is the one with short title tgtCpShortTitle,
        with merge logic outer. 

        Note
        ----
        Merging is restricted to Super Admins. The CPs must have the same format for PPI, visits and specimens. Or the target CP 
        has no specific formats. 

        Parameters
        ----------
        src_cp : string
            String with the shortTitle of the source collection Protocol.
        
        trgcp : string
            String with the shortTitle of the target collection Protocol.

        Returns
        -------
        JSON-dict
            JSON dict with the short titles of the source and target Colelction Protocols.
        &#34;&#34;&#34;

        data = self.jsons.merge_cps(src_cp = src_cp, trg_cp = trg_cp)
        r = self.cps.merge_colelction_protocols(params = data)

        return r


    def create_cp(self, short_title , title, pi_mail, sites, time_start=None, time_end=None,  man_id=None, coords=None,
                           consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                           derivativeLabelFmt =None, man_visit_name=None, man_spec_label=None, aliquots_in_same=None, activity=None,
                           aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None):
        
        &#34;&#34;&#34;Create a Collection protocol with the given Parameters
        
        Create a collection protocol with the Parameters passed to the function.

        Parameters
        ----------
        short_title : string
            Short title of the Collection Protocol.

        title : string
            Title of the Collection Protocol.

        pi_mail : string
            Email Address of the Principal Investigator.
        
        time_start: string
            String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
        
        time_end: string
            String with the end_time of the collection Protocol in the timeformat specified in the System configuration.

        sites: list
            Sites which are assigned to the collection Protocl.
        
        man_id : string
            OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.

        coords: dict
            dict with Coordinators and coordinator ids in it.

        consentsWaived : string
            OpenSpecimen&#39;s boolean true/false if consent should be waived.

        eth_cons_id : string
            Ethical aproavel id.

        part_no : string
            String with number of anticipated Participant count.

        desc_url = string
            URL with the decription of the Collection Protocol.
        
        visitNameFMT : string
            String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.

        man_visit_name : string
            String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
        
        activity : string
            String with the acitivity status of the Specimen.
        
        Returns
        -------
        dict
            Details of the created Collection Protocol, or the OpenSpecimen&#39;s error message.
        &#34;&#34;&#34;

        params = self.jsons.create_CP_json(short_title=short_title, title=title, pi_mail=pi_mail, time_start=time_start, time_end=time_end,
                    sites=sites, man_id=man_id, coords=coords, consentsWaived=consentsWaived, eth_cons_id=eth_cons_id, part_no=part_no,
                    desc_url=desc_url, visitNameFmt=visitNameFmt, specimenLabelFmt=specimenLabelFmt, derivativeLabelFmt=derivativeLabelFmt,
                    man_visit_name=man_visit_name, man_spec_label=man_spec_label, aliquots_in_same=aliquots_in_same, activity=activity,
                    aliquotLabelFmt=aliquotLabelFmt, ppidFmt=ppidFmt, specimenCentric=specimenCentric)

        r = self.cps.create_collection_protocol(params = params)

        return r
    
    def update_cp(self, cpid, short_title = None, title=None, pi_mail=None, time_start=None, time_end=None, sites=None, man_id=False, coords=None,
                           consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                           derivativeLabelFmt =None, man_visit_name=False, man_spec_label=True, aliquots_in_same=None, activity=None,
                           aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None):

        &#34;&#34;&#34;Update a Collection protocol with the given Parameters.
        
        Update a collection protocol with the Parameters passed to the function. The Collection protocol ID 
        cpid is mandatory.

        Notes
        -----
        The parameters except cpid are mandatory. All values not passed will not get changed.
        
        Parameters
        ----------
        cpid : int
            ID of the Colelction Protocol which should get updated.

        short_title : string
            Short title of the Collection Protocol.

        title : string
            Title of the Collection Protocol.

        pi_mail : string
            Email Address of the Principal Investigator.
        
        time_start: string
            String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
        
        time_end: string
            String with the end_time of the collection Protocol in the timeformat specified in the System configuration.

        sites: list
            Sites which are assigned to the Collection Protocl.
        
        man_id : string
            OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.

        coords: dict
            dict with Coordinators and coordinator ids in it.

        consentsWaived : string
            OpenSpecimen&#39;s boolean true/false if consent should be waived.

        eth_cons_id : string
            Ethical aproavel id.

        part_no : string
            String with number of anticipated Participant count.

        desc_url = string
            URL with the decription of the Collection Protocol.
        
        visitNameFMT : string
            String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.

        man_visit_name : string
            String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
        
        activity : string
            String with the acitivity status of the Specimen.
        
        Returns
        -------
        dict
            Details of the created Collection Protocol, or the OpenSpecimen&#39;s error message.
        &#34;&#34;&#34;
    
        params = self.jsons.create_CP_json(cpid =cpid, short_title=short_title, title=title, pi_mail=pi_mail, time_start=time_start, time_end=time_end,
                    sites=sites, man_id=man_id, coords=coords, consentsWaived=consentsWaived, eth_cons_id=eth_cons_id, part_no=part_no,
                    desc_url=desc_url, visitNameFmt=visitNameFmt, specimenLabelFmt=specimenLabelFmt, derivativeLabelFmt=derivativeLabelFmt,
                    man_visit_name=man_visit_name, man_spec_label=man_spec_label, aliquots_in_same=aliquots_in_same, activity=activity,
                    aliquotLabelFmt=aliquotLabelFmt, ppidFmt=ppidFmt, specimenCentric=specimenCentric)
        
        r = self.cps.update_collection_protocol(cpid =cpid, params = params)

        return r</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util"><code class="flex name class">
<span>class <span class="ident">collection_protocol_util</span></span>
</code></dt>
<dd>
<div class="desc"><p>Utility class for Site API calls</p>
<p>This class handles the API calls for OpenSpecimen Collection Protocol. It can create, update,
search
and merge
Protocols.
The output is a JSON dict or the Error message as JSON dict, except the Pandas dataframe.</p>
<h2 id="notes">Notes</h2>
<p>In order to use this and also the other classes, the user has to know OpenSpecimen. In the core classes one can
just pass the parameters via JSON-formatted string. This means the user has to know the keywords.
The API calls are documented in <a href="https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs">https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs</a> and
the calls refer to this site. More details can be seen in the documentation.</p>
<h2 id="example">Example</h2>
<p>A code example, where the Collection protocols are handled is in the Jupyter-Notebook::</p>
<pre><code>$ jupyter notebook main.ipynb
</code></pre>
<p>Constructor of the Class collection_protocol_util</p>
<p>Constructor of the class colelction_protocol, can handle the basic API-calls
of the collection protocol in OpenSpecimen. Connects this class to OpenSpecimen
specific request handle (os_core.request_util.py) and the os_core classes
Json_fatory, url_gen and collection_protocol</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>base_url</code></strong> :&ensp;<code>string</code></dt>
<dd>URL to openspecimen, has the format: http(s)://<host>:<port>/openspecimen/rest/ng</dd>
<dt><strong><code>auth</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Consits of two strings ( loginname , password)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class collection_protocol_util:

    &#34;&#34;&#34;Utility class for Site API calls

    This class handles the API calls for OpenSpecimen Collection Protocol. It can create, update, 
    search  and merge  Protocols.
    The output is a JSON dict or the Error message as JSON dict, except the Pandas dataframe.

    Notes
    -----
    In order to use this and also the other classes, the user has to know OpenSpecimen. In the core classes one can
    just pass the parameters via JSON-formatted string. This means the user has to know the keywords.
    The API calls are documented in https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs and 
    the calls refer to this site. More details can be seen in the documentation.

    Example
    -------

    A code example, where the Collection protocols are handled is in the Jupyter-Notebook::

        $ jupyter notebook main.ipynb
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;Constructor of the Class collection_protocol_util

        Constructor of the class colelction_protocol, can handle the basic API-calls
        of the collection protocol in OpenSpecimen. Connects this class to OpenSpecimen
        specific request handle (os_core.request_util.py) and the os_core classes
        Json_fatory, url_gen and collection_protocol

        Parameters
        ----------
        base_url : string
            URL to openspecimen, has the format: http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/ng
        auth : tuple
            Consits of two strings ( loginname , password)
        &#34;&#34;&#34;

        self.jsons = Json_factory()
        self.urls = url_gen()
        self.cps = collection_protocol()

  
    def search_cps(self, searchstring = None, title = None, piid = None, reponame = None, startat = None, maxresults = None, detailedlist = None):

        &#34;&#34;&#34;Search for Colelction Protocols with specific values.

        Search for one or more Collection Protocols with the search_string defined. The search string looks like:
        http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/np/collection-protocols?{param_1}={value_1}&amp;...&amp;{param_x}={value_x}
        With the class collection_protocol_util from os_util and function ::search_cps:: the search string is generated
        and this function is called. Not all keys from OpenSpecimen can be easily searched after.

        Parameters
        ----------
        search_string : string
            openSpecimen&#39;s Advanced Query Language[optional]. Substring of the title or shorttitle

        title : string
            Name of the desired Collection Protocol
        
        ppid : string or int
            Id of the Pricincipal Investigator, gets converted to a string[optional].
        
        reponame : string
            Name of the Repository in which the Collection Protocol is[optional].
        
        startat : int
            Value which one of the outcomes is the first to show, if not specified OpenSpecimen takes 0.
        
        maxresults : int
            Value how many Collection Protocols are shown, if not specified OpenSpecimen takes 100.
        
        detailedList: string
            String in OpenSpecimen&#39;s boolean format, permissable values are true/false. If not specified, OpenSpecimen takes false.

        Returns
        -------
        JSON-dict
            [Details of the matching Collection Protocols, if no one matches it is an empty list.
        &#34;&#34;&#34;

        search_string = self.urls.cp_search_url_gen(searchstring = searchstring, title = title, piid = piid, reponame = reponame,
                                                    startat = startat, maxresults = maxresults, detailedlist = detailedlist)

        r = self.cps.search_collection_protocols(search_string = search_string)

        return r

    def merge_cps(self, src_cp, trg_cp):

        &#34;&#34;&#34;Merge two Collection protocols

        Merge two Colelction Protocols which are defined in src_cp and trg_cp together. To call this function the short titles of
        the source and target collection protocol has to be known. The merged Protocol is the one with short title tgtCpShortTitle,
        with merge logic outer. 

        Note
        ----
        Merging is restricted to Super Admins. The CPs must have the same format for PPI, visits and specimens. Or the target CP 
        has no specific formats. 

        Parameters
        ----------
        src_cp : string
            String with the shortTitle of the source collection Protocol.
        
        trgcp : string
            String with the shortTitle of the target collection Protocol.

        Returns
        -------
        JSON-dict
            JSON dict with the short titles of the source and target Colelction Protocols.
        &#34;&#34;&#34;

        data = self.jsons.merge_cps(src_cp = src_cp, trg_cp = trg_cp)
        r = self.cps.merge_colelction_protocols(params = data)

        return r


    def create_cp(self, short_title , title, pi_mail, sites, time_start=None, time_end=None,  man_id=None, coords=None,
                           consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                           derivativeLabelFmt =None, man_visit_name=None, man_spec_label=None, aliquots_in_same=None, activity=None,
                           aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None):
        
        &#34;&#34;&#34;Create a Collection protocol with the given Parameters
        
        Create a collection protocol with the Parameters passed to the function.

        Parameters
        ----------
        short_title : string
            Short title of the Collection Protocol.

        title : string
            Title of the Collection Protocol.

        pi_mail : string
            Email Address of the Principal Investigator.
        
        time_start: string
            String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
        
        time_end: string
            String with the end_time of the collection Protocol in the timeformat specified in the System configuration.

        sites: list
            Sites which are assigned to the collection Protocl.
        
        man_id : string
            OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.

        coords: dict
            dict with Coordinators and coordinator ids in it.

        consentsWaived : string
            OpenSpecimen&#39;s boolean true/false if consent should be waived.

        eth_cons_id : string
            Ethical aproavel id.

        part_no : string
            String with number of anticipated Participant count.

        desc_url = string
            URL with the decription of the Collection Protocol.
        
        visitNameFMT : string
            String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.

        man_visit_name : string
            String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
        
        activity : string
            String with the acitivity status of the Specimen.
        
        Returns
        -------
        dict
            Details of the created Collection Protocol, or the OpenSpecimen&#39;s error message.
        &#34;&#34;&#34;

        params = self.jsons.create_CP_json(short_title=short_title, title=title, pi_mail=pi_mail, time_start=time_start, time_end=time_end,
                    sites=sites, man_id=man_id, coords=coords, consentsWaived=consentsWaived, eth_cons_id=eth_cons_id, part_no=part_no,
                    desc_url=desc_url, visitNameFmt=visitNameFmt, specimenLabelFmt=specimenLabelFmt, derivativeLabelFmt=derivativeLabelFmt,
                    man_visit_name=man_visit_name, man_spec_label=man_spec_label, aliquots_in_same=aliquots_in_same, activity=activity,
                    aliquotLabelFmt=aliquotLabelFmt, ppidFmt=ppidFmt, specimenCentric=specimenCentric)

        r = self.cps.create_collection_protocol(params = params)

        return r
    
    def update_cp(self, cpid, short_title = None, title=None, pi_mail=None, time_start=None, time_end=None, sites=None, man_id=False, coords=None,
                           consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                           derivativeLabelFmt =None, man_visit_name=False, man_spec_label=True, aliquots_in_same=None, activity=None,
                           aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None):

        &#34;&#34;&#34;Update a Collection protocol with the given Parameters.
        
        Update a collection protocol with the Parameters passed to the function. The Collection protocol ID 
        cpid is mandatory.

        Notes
        -----
        The parameters except cpid are mandatory. All values not passed will not get changed.
        
        Parameters
        ----------
        cpid : int
            ID of the Colelction Protocol which should get updated.

        short_title : string
            Short title of the Collection Protocol.

        title : string
            Title of the Collection Protocol.

        pi_mail : string
            Email Address of the Principal Investigator.
        
        time_start: string
            String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
        
        time_end: string
            String with the end_time of the collection Protocol in the timeformat specified in the System configuration.

        sites: list
            Sites which are assigned to the Collection Protocl.
        
        man_id : string
            OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.

        coords: dict
            dict with Coordinators and coordinator ids in it.

        consentsWaived : string
            OpenSpecimen&#39;s boolean true/false if consent should be waived.

        eth_cons_id : string
            Ethical aproavel id.

        part_no : string
            String with number of anticipated Participant count.

        desc_url = string
            URL with the decription of the Collection Protocol.
        
        visitNameFMT : string
            String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.

        man_visit_name : string
            String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
        
        activity : string
            String with the acitivity status of the Specimen.
        
        Returns
        -------
        dict
            Details of the created Collection Protocol, or the OpenSpecimen&#39;s error message.
        &#34;&#34;&#34;
    
        params = self.jsons.create_CP_json(cpid =cpid, short_title=short_title, title=title, pi_mail=pi_mail, time_start=time_start, time_end=time_end,
                    sites=sites, man_id=man_id, coords=coords, consentsWaived=consentsWaived, eth_cons_id=eth_cons_id, part_no=part_no,
                    desc_url=desc_url, visitNameFmt=visitNameFmt, specimenLabelFmt=specimenLabelFmt, derivativeLabelFmt=derivativeLabelFmt,
                    man_visit_name=man_visit_name, man_spec_label=man_spec_label, aliquots_in_same=aliquots_in_same, activity=activity,
                    aliquotLabelFmt=aliquotLabelFmt, ppidFmt=ppidFmt, specimenCentric=specimenCentric)
        
        r = self.cps.update_collection_protocol(cpid =cpid, params = params)

        return r</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.create_cp"><code class="name flex">
<span>def <span class="ident">create_cp</span></span>(<span>self, short_title, title, pi_mail, sites, time_start=None, time_end=None, man_id=None, coords=None, consentsWaived=None, eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, derivativeLabelFmt=None, man_visit_name=None, man_spec_label=None, aliquots_in_same=None, activity=None, aliquotLabelFmt=None, ppidFmt=None, specimenCentric=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Collection protocol with the given Parameters</p>
<p>Create a collection protocol with the Parameters passed to the function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>short_title</code></strong> :&ensp;<code>string</code></dt>
<dd>Short title of the Collection Protocol.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code></dt>
<dd>Title of the Collection Protocol.</dd>
<dt><strong><code>pi_mail</code></strong> :&ensp;<code>string</code></dt>
<dd>Email Address of the Principal Investigator.</dd>
<dt><strong><code>time_start</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the start_time of the collection Protocol in the timeformat specified in the System configuration.</dd>
<dt><strong><code>time_end</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the end_time of the collection Protocol in the timeformat specified in the System configuration.</dd>
<dt><strong><code>sites</code></strong> :&ensp;<code>list</code></dt>
<dd>Sites which are assigned to the collection Protocl.</dd>
<dt><strong><code>man_id</code></strong> :&ensp;<code>string</code></dt>
<dd>OpenSpecimen's boolean true/false if the manual PPID creation is enabled.</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict with Coordinators and coordinator ids in it.</dd>
<dt><strong><code>consentsWaived</code></strong> :&ensp;<code>string</code></dt>
<dd>OpenSpecimen's boolean true/false if consent should be waived.</dd>
<dt><strong><code>eth_cons_id</code></strong> :&ensp;<code>string</code></dt>
<dd>Ethical aproavel id.</dd>
<dt><strong><code>part_no</code></strong> :&ensp;<code>string</code></dt>
<dd>String with number of anticipated Participant count.</dd>
</dl>
<p>desc_url = string
URL with the decription of the Collection Protocol.</p>
<dl>
<dt><strong><code>visitNameFMT</code></strong> :&ensp;<code>string</code></dt>
<dd>String which contains the OpenSpecimen's token for creating Visit Names automatically.</dd>
<dt><strong><code>man_visit_name</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Visits should be created manually.</dd>
<dt><strong><code>man_spec_label</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Specimen Labels should be created manually.</dd>
<dt><strong><code>man_spec_label</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Aliquotes are stored in the same Container.</dd>
<dt><strong><code>activity</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the acitivity status of the Specimen.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Details of the created Collection Protocol, or the OpenSpecimen's error message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cp(self, short_title , title, pi_mail, sites, time_start=None, time_end=None,  man_id=None, coords=None,
                       consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                       derivativeLabelFmt =None, man_visit_name=None, man_spec_label=None, aliquots_in_same=None, activity=None,
                       aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None):
    
    &#34;&#34;&#34;Create a Collection protocol with the given Parameters
    
    Create a collection protocol with the Parameters passed to the function.

    Parameters
    ----------
    short_title : string
        Short title of the Collection Protocol.

    title : string
        Title of the Collection Protocol.

    pi_mail : string
        Email Address of the Principal Investigator.
    
    time_start: string
        String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
    
    time_end: string
        String with the end_time of the collection Protocol in the timeformat specified in the System configuration.

    sites: list
        Sites which are assigned to the collection Protocl.
    
    man_id : string
        OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.

    coords: dict
        dict with Coordinators and coordinator ids in it.

    consentsWaived : string
        OpenSpecimen&#39;s boolean true/false if consent should be waived.

    eth_cons_id : string
        Ethical aproavel id.

    part_no : string
        String with number of anticipated Participant count.

    desc_url = string
        URL with the decription of the Collection Protocol.
    
    visitNameFMT : string
        String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.

    man_visit_name : string
        String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
    
    man_spec_label : string
        String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
    
    man_spec_label : string
        String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
    
    activity : string
        String with the acitivity status of the Specimen.
    
    Returns
    -------
    dict
        Details of the created Collection Protocol, or the OpenSpecimen&#39;s error message.
    &#34;&#34;&#34;

    params = self.jsons.create_CP_json(short_title=short_title, title=title, pi_mail=pi_mail, time_start=time_start, time_end=time_end,
                sites=sites, man_id=man_id, coords=coords, consentsWaived=consentsWaived, eth_cons_id=eth_cons_id, part_no=part_no,
                desc_url=desc_url, visitNameFmt=visitNameFmt, specimenLabelFmt=specimenLabelFmt, derivativeLabelFmt=derivativeLabelFmt,
                man_visit_name=man_visit_name, man_spec_label=man_spec_label, aliquots_in_same=aliquots_in_same, activity=activity,
                aliquotLabelFmt=aliquotLabelFmt, ppidFmt=ppidFmt, specimenCentric=specimenCentric)

    r = self.cps.create_collection_protocol(params = params)

    return r</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.merge_cps"><code class="name flex">
<span>def <span class="ident">merge_cps</span></span>(<span>self, src_cp, trg_cp)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge two Collection protocols</p>
<p>Merge two Colelction Protocols which are defined in src_cp and trg_cp together. To call this function the short titles of
the source and target collection protocol has to be known. The merged Protocol is the one with short title tgtCpShortTitle,
with merge logic outer. </p>
<h2 id="note">Note</h2>
<p>Merging is restricted to Super Admins. The CPs must have the same format for PPI, visits and specimens. Or the target CP
has no specific formats. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>src_cp</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the shortTitle of the source collection Protocol.</dd>
<dt><strong><code>trgcp</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the shortTitle of the target collection Protocol.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>JSON dict with the short titles of the source and target Colelction Protocols.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_cps(self, src_cp, trg_cp):

    &#34;&#34;&#34;Merge two Collection protocols

    Merge two Colelction Protocols which are defined in src_cp and trg_cp together. To call this function the short titles of
    the source and target collection protocol has to be known. The merged Protocol is the one with short title tgtCpShortTitle,
    with merge logic outer. 

    Note
    ----
    Merging is restricted to Super Admins. The CPs must have the same format for PPI, visits and specimens. Or the target CP 
    has no specific formats. 

    Parameters
    ----------
    src_cp : string
        String with the shortTitle of the source collection Protocol.
    
    trgcp : string
        String with the shortTitle of the target collection Protocol.

    Returns
    -------
    JSON-dict
        JSON dict with the short titles of the source and target Colelction Protocols.
    &#34;&#34;&#34;

    data = self.jsons.merge_cps(src_cp = src_cp, trg_cp = trg_cp)
    r = self.cps.merge_colelction_protocols(params = data)

    return r</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.search_cps"><code class="name flex">
<span>def <span class="ident">search_cps</span></span>(<span>self, searchstring=None, title=None, piid=None, reponame=None, startat=None, maxresults=None, detailedlist=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for Colelction Protocols with specific values.</p>
<p>Search for one or more Collection Protocols with the search_string defined. The search string looks like:
http(s)://<host>:<port>/openspecimen/rest/np/collection-protocols?{param_1}={value_1}&amp;&hellip;&amp;{param_x}={value_x}
With the class collection_protocol_util from os_util and function ::search_cps:: the search string is generated
and this function is called. Not all keys from OpenSpecimen can be easily searched after.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>search_string</code></strong> :&ensp;<code>string</code></dt>
<dd>openSpecimen's Advanced Query Language[optional]. Substring of the title or shorttitle</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the desired Collection Protocol</dd>
<dt><strong><code>ppid</code></strong> :&ensp;<code>string</code> or <code>int</code></dt>
<dd>Id of the Pricincipal Investigator, gets converted to a string[optional].</dd>
<dt><strong><code>reponame</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the Repository in which the Collection Protocol is[optional].</dd>
<dt><strong><code>startat</code></strong> :&ensp;<code>int</code></dt>
<dd>Value which one of the outcomes is the first to show, if not specified OpenSpecimen takes 0.</dd>
<dt><strong><code>maxresults</code></strong> :&ensp;<code>int</code></dt>
<dd>Value how many Collection Protocols are shown, if not specified OpenSpecimen takes 100.</dd>
<dt><strong><code>detailedList</code></strong> :&ensp;<code>string</code></dt>
<dd>String in OpenSpecimen's boolean format, permissable values are true/false. If not specified, OpenSpecimen takes false.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>[Details of the matching Collection Protocols, if no one matches it is an empty list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_cps(self, searchstring = None, title = None, piid = None, reponame = None, startat = None, maxresults = None, detailedlist = None):

    &#34;&#34;&#34;Search for Colelction Protocols with specific values.

    Search for one or more Collection Protocols with the search_string defined. The search string looks like:
    http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/np/collection-protocols?{param_1}={value_1}&amp;...&amp;{param_x}={value_x}
    With the class collection_protocol_util from os_util and function ::search_cps:: the search string is generated
    and this function is called. Not all keys from OpenSpecimen can be easily searched after.

    Parameters
    ----------
    search_string : string
        openSpecimen&#39;s Advanced Query Language[optional]. Substring of the title or shorttitle

    title : string
        Name of the desired Collection Protocol
    
    ppid : string or int
        Id of the Pricincipal Investigator, gets converted to a string[optional].
    
    reponame : string
        Name of the Repository in which the Collection Protocol is[optional].
    
    startat : int
        Value which one of the outcomes is the first to show, if not specified OpenSpecimen takes 0.
    
    maxresults : int
        Value how many Collection Protocols are shown, if not specified OpenSpecimen takes 100.
    
    detailedList: string
        String in OpenSpecimen&#39;s boolean format, permissable values are true/false. If not specified, OpenSpecimen takes false.

    Returns
    -------
    JSON-dict
        [Details of the matching Collection Protocols, if no one matches it is an empty list.
    &#34;&#34;&#34;

    search_string = self.urls.cp_search_url_gen(searchstring = searchstring, title = title, piid = piid, reponame = reponame,
                                                startat = startat, maxresults = maxresults, detailedlist = detailedlist)

    r = self.cps.search_collection_protocols(search_string = search_string)

    return r</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.update_cp"><code class="name flex">
<span>def <span class="ident">update_cp</span></span>(<span>self, cpid, short_title=None, title=None, pi_mail=None, time_start=None, time_end=None, sites=None, man_id=False, coords=None, consentsWaived=None, eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, derivativeLabelFmt=None, man_visit_name=False, man_spec_label=True, aliquots_in_same=None, activity=None, aliquotLabelFmt=None, ppidFmt=None, specimenCentric=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a Collection protocol with the given Parameters.</p>
<p>Update a collection protocol with the Parameters passed to the function. The Collection protocol ID
cpid is mandatory.</p>
<h2 id="notes">Notes</h2>
<p>The parameters except cpid are mandatory. All values not passed will not get changed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cpid</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the Colelction Protocol which should get updated.</dd>
<dt><strong><code>short_title</code></strong> :&ensp;<code>string</code></dt>
<dd>Short title of the Collection Protocol.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code></dt>
<dd>Title of the Collection Protocol.</dd>
<dt><strong><code>pi_mail</code></strong> :&ensp;<code>string</code></dt>
<dd>Email Address of the Principal Investigator.</dd>
<dt><strong><code>time_start</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the start_time of the collection Protocol in the timeformat specified in the System configuration.</dd>
<dt><strong><code>time_end</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the end_time of the collection Protocol in the timeformat specified in the System configuration.</dd>
<dt><strong><code>sites</code></strong> :&ensp;<code>list</code></dt>
<dd>Sites which are assigned to the Collection Protocl.</dd>
<dt><strong><code>man_id</code></strong> :&ensp;<code>string</code></dt>
<dd>OpenSpecimen's boolean true/false if the manual PPID creation is enabled.</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict with Coordinators and coordinator ids in it.</dd>
<dt><strong><code>consentsWaived</code></strong> :&ensp;<code>string</code></dt>
<dd>OpenSpecimen's boolean true/false if consent should be waived.</dd>
<dt><strong><code>eth_cons_id</code></strong> :&ensp;<code>string</code></dt>
<dd>Ethical aproavel id.</dd>
<dt><strong><code>part_no</code></strong> :&ensp;<code>string</code></dt>
<dd>String with number of anticipated Participant count.</dd>
</dl>
<p>desc_url = string
URL with the decription of the Collection Protocol.</p>
<dl>
<dt><strong><code>visitNameFMT</code></strong> :&ensp;<code>string</code></dt>
<dd>String which contains the OpenSpecimen's token for creating Visit Names automatically.</dd>
<dt><strong><code>man_visit_name</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Visits should be created manually.</dd>
<dt><strong><code>man_spec_label</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Specimen Labels should be created manually.</dd>
<dt><strong><code>man_spec_label</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Aliquotes are stored in the same Container.</dd>
<dt><strong><code>activity</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the acitivity status of the Specimen.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Details of the created Collection Protocol, or the OpenSpecimen's error message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_cp(self, cpid, short_title = None, title=None, pi_mail=None, time_start=None, time_end=None, sites=None, man_id=False, coords=None,
                       consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                       derivativeLabelFmt =None, man_visit_name=False, man_spec_label=True, aliquots_in_same=None, activity=None,
                       aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None):

    &#34;&#34;&#34;Update a Collection protocol with the given Parameters.
    
    Update a collection protocol with the Parameters passed to the function. The Collection protocol ID 
    cpid is mandatory.

    Notes
    -----
    The parameters except cpid are mandatory. All values not passed will not get changed.
    
    Parameters
    ----------
    cpid : int
        ID of the Colelction Protocol which should get updated.

    short_title : string
        Short title of the Collection Protocol.

    title : string
        Title of the Collection Protocol.

    pi_mail : string
        Email Address of the Principal Investigator.
    
    time_start: string
        String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
    
    time_end: string
        String with the end_time of the collection Protocol in the timeformat specified in the System configuration.

    sites: list
        Sites which are assigned to the Collection Protocl.
    
    man_id : string
        OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.

    coords: dict
        dict with Coordinators and coordinator ids in it.

    consentsWaived : string
        OpenSpecimen&#39;s boolean true/false if consent should be waived.

    eth_cons_id : string
        Ethical aproavel id.

    part_no : string
        String with number of anticipated Participant count.

    desc_url = string
        URL with the decription of the Collection Protocol.
    
    visitNameFMT : string
        String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.

    man_visit_name : string
        String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
    
    man_spec_label : string
        String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
    
    man_spec_label : string
        String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
    
    activity : string
        String with the acitivity status of the Specimen.
    
    Returns
    -------
    dict
        Details of the created Collection Protocol, or the OpenSpecimen&#39;s error message.
    &#34;&#34;&#34;

    params = self.jsons.create_CP_json(cpid =cpid, short_title=short_title, title=title, pi_mail=pi_mail, time_start=time_start, time_end=time_end,
                sites=sites, man_id=man_id, coords=coords, consentsWaived=consentsWaived, eth_cons_id=eth_cons_id, part_no=part_no,
                desc_url=desc_url, visitNameFmt=visitNameFmt, specimenLabelFmt=specimenLabelFmt, derivativeLabelFmt=derivativeLabelFmt,
                man_visit_name=man_visit_name, man_spec_label=man_spec_label, aliquots_in_same=aliquots_in_same, activity=activity,
                aliquotLabelFmt=aliquotLabelFmt, ppidFmt=ppidFmt, specimenCentric=specimenCentric)
    
    r = self.cps.update_collection_protocol(cpid =cpid, params = params)

    return r</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="OpenSpecimenAPIconnector.os_util" href="index.html">OpenSpecimenAPIconnector.os_util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util" href="#OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util">collection_protocol_util</a></code></h4>
<ul class="">
<li><code><a title="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.create_cp" href="#OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.create_cp">create_cp</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.merge_cps" href="#OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.merge_cps">merge_cps</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.search_cps" href="#OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.search_cps">search_cps</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.update_cp" href="#OpenSpecimenAPIconnector.os_util.collection_protocol_util.collection_protocol_util.update_cp">update_cp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>