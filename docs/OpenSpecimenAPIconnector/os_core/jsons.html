<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>OpenSpecimenAPIconnector.os_core.jsons API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>OpenSpecimenAPIconnector.os_core.jsons</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
from datetime import date
from datetime import datetime
from dateutil.relativedelta import relativedelta
import pandas as pd




class Json_factory():

    def __init__(self):
        pass

    ## first approach to be overhauled
    ##TODO Decide upon way of json creation/storage for OS operations, the current idea is to set mandatory values to
    ## boolean true by default. than a random generator can create the values in fixed order and they can be set
    ## according to the boolean. Even better would be the restriction to use pandas data frames directly and create the
    ## json once data entry is done. Another important question is how to deal with custom value fields in various cases.
    ## Further, where possible, the csv import option should be used and json creation should be left to the numerous
    ## methods within Open Specimen
    # creation jsons:
    # participant
    def create_participant_json(self, regdate = None, id_ = None, cpid = None, cptitle = None, 
                        cpshorttitle =None, ppid = None, firstname = None, middlename = None, 
                        lastname = None, uid = None, birthdate = None, vitalstatus = None, 
                        deathdate = None, gender = None, race = None, ethnicities = None, cprid=None,
                        sexgenotype = None, pmis = None, mrn = None, sitename = None, empi =None):

        &#34;&#34;&#34;Creates a JSON-formated string for participant creation
        This function creates the json corresponding to the cpr_util function
        Notes
        ----- 
        Mandatory parameters are passed as positional arguments in the caliing function
        Parameters
        ----------
        regdate : string
            Mandatory field with date of registration in the format which is defined in the systemsettings of openSpecimen.
        cprid : int
            Unique ID of the Participant&#39;s Registration.
        id_ : int
            Unique ID of the Participant.
        cpid : int
            Unique ID of the Collection Protocol, which is autogenerated from OpenSpecimen. cpid or cptitle or cpshorttile is mandatory.
        
        cptitle : string
            Unique title of the Collection Protocol. cpid or cptitle or cpshorttile is mandatory.
        cpshorttitle : string
            Unique Acronym of the Collection Protocol. cpid or cptitle or cpshorttile is mandatory.
        
        ppid : string
            Participant protocol ID, is mandatory if created manaully and have to be empty if it is autogenerated.
            This is a protocol setting.
        
        firstname : string
            Participants first name.
        
        middlename : string
            Participants middle name.
        
        lastname : string
            Participants last name.
        
        uid : string
            Unique identifier e.g. social security number.
        
        birthdate : string
            Birthdate in the format which is defined in the systemsettings of OpenSpecimen.
        vitalstatus : string
            Vital status of the Participant.
        
        deathdate : string
            Deathdate in the format which is defined in the systemsettings of OpenSpecimen.
        
        gender : string
            Gender of the participant, permissable values are Male, Female, Unknown, Unspecified.
        
        race : string
            Participants racial origination, permissable values are {American Indian or Alaska Native, Asian, black or Afro American, Native Hawaiian
            or other Pacific Islander, Not REported, Unknown, White}
        
        ethnicities : string
            Participants ethnicities, permissable values are: {Hispanic or Latino, Not Hispanic or Latino, Not Reported, Unknown}
        
        sexgenotype : string
            Participants sex Genotype, permissable values are {XX Genotype, XY Genotype, XXX, Klinefelterâ€™s Syndrome, XXXY syndrome, 
            XXYY syndrome, Mosaic including XXXXY, Penta X syndrome}
        
        pmis : string
            Collection of the Participants medical record numner.
        
        mrn : string
            Participants medical record number.
        sitename : string
            Name of the site, where the participant is registrated.
        empi : string
            Enterprise master patient index number.
        Returns
        -------
        JSON-dict
            Details of the updated Participant or the OpenSpecimen error message as Dictornary.
        &#34;&#34;&#34;

        part = {
            &#34;id&#34;: id_,
            &#34;firstName&#34;: firstname,
            &#34;middleName&#34;: middlename,
            &#34;lastName&#34;: lastname,
            &#34;uid&#34;:uid,
            &#34;birthDate&#34;: birthdate,
            &#34;vitalStatus&#34;: vitalstatus,
            &#34;deathDate&#34;: deathdate,
            &#34;gender&#34;: gender,
            &#34;race&#34;: race,
            &#34;sexGenotype&#34;: sexgenotype,
            &#34;ethnicities&#34;: ethnicities,
            &#34;pmis&#34;: pmis,
            &#34;mrn&#34;: mrn,
            &#34;siteName&#34;: sitename,
            &#34;empi&#34;: empi                
        }

        part = {k: v for k, v in part.items() if v is not None}

        data = {
            &#34;cpId&#34;: str(cpid),
            &#34;registrationDate&#34;: regdate,
            &#34;ppid&#34;: str(ppid),
            &#34;cpShortTitle&#34;: cpshorttitle,
            &#34;cpTitle&#34;: cptitle
        }

        data = {k: v for k, v in data.items() if v is not None}

        data[&#39;participant&#39;]=part

        return json.dumps(data)

    # Collection Protocoll
    def create_CP_json(self, short_title = None, title=None, pi_mail=None, time_start=None, time_end=None, sites=None, man_id=False, coords=None,
                           consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                           derivativeLabelFmt =None, man_visit_name=False, man_spec_label=True, aliquots_in_same=None, activity=None,
                           aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None, cpid=None):

        &#34;&#34;&#34;Creates the JSON-formated string corresponding to the collection_protocol_util funciton create_CP
        
        Notes
        -----
        Mandatory paramters are passed as positional args within the calling util class
        Parameters
        ----------
        short_title : string
            Short title of the Collection Protocol.
        title : string
            Title of the Collection Protocol.
        pi_mail : string
            Email Address of the Principal Investigator.
        
        time_start: string
            String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
        
        time_end: string
            String with the end_time of the collection Protocol in the timeformat specified in the System configuration.
        sites: list
            Sites which are assigned to the collection Protocol.
        
        man_id : string
            OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.
        coords: dict
            dict with Coordinators and coordinator ids in it.
        consentsWaived : string
            OpenSpecimen&#39;s boolean true/false if consent should be waived.
        eth_cons_id : string
            Ethical aproavel id.
        part_no : string
            String with number of anticipated Participant count.
        desc_url = string
            URL with the decription of the Collection Protocol.
        
        visitNameFMT : string
            String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.
        man_visit_name : string
            String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
        
        activity : string
            String with the acitivity status of the Specimen.
        cpid : int
            Integer with the Unique ID of the Collection Protocol.
        
        Returns
        -------
        JSON-formated-string containing the collection protocol information neccesary for creation
        &#34;&#34;&#34;

        site_arr = []
        for item in sites:
            site_arr.append(
                
                    {&#34;siteName&#34;: item},
                
            )
        
        data = {
            &#34;id&#34;: cpid,
            &#34;shortTitle&#34;: short_title,
            &#34;title&#34;: title,
            &#34;code&#34;: None,
            &#34;principalInvestigator&#34;:
                {
                    &#34;loginName&#34;: pi_mail,
                    &#34;domain&#34;: &#34;openspecimen&#34;
                },
            &#34;startDate&#34;: time_start,
            &#34;endDate&#34;: time_end,
            &#34;ppidFmt&#34;: ppidFmt,
            &#34;manualPpidEnabled&#34;: man_id,
            &#34;cpSites&#34;: site_arr,
            &#34;consentsWaived&#34;: consentsWaived,
            &#34;irbId&#34;: eth_cons_id,
            &#34;anticipatedParticipantsCount&#34;: part_no,
            &#34;descriptionUrl&#34;: desc_url,
            &#34;specimenLabelFmt&#34;: specimenLabelFmt,
            &#34;derivativeLabelFmt&#34;: derivativeLabelFmt,
            &#34;aliquotLabelFmt&#34;: aliquotLabelFmt,
            &#34;visitNameFmt&#34;: visitNameFmt,
            &#34;manualVisitNameEnabled&#34;: man_visit_name,
            &#34;manualSpecLabelEnabled&#34;: man_spec_label,
            &#34;aliquotsInSameContainer&#34;: aliquots_in_same,
            &#34;activityStatus&#34;: activity,
            &#34;specimenCentric&#34;: specimenCentric
        }
        if coords != None:
            data[&#34;coordinators&#34;] = {&#34;loginName&#34; : coords,&#34;domain&#34; : &#34;openspecimen&#34;}

        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)

    # Collection Protocol event
    def create_cp_event_json(self, label=None, point=None, cp=None, site=None, diagnosis=None, status=None, activity=None, unit=None, code=None):
        
        &#34;&#34;&#34;Create JSON-formated string needed for event creation
        
        Create an event for a given Collection Protocol. Details of the parameters can be found in
        the parameters section.
        Notes
        -----
        Mandatory paramters are passed as positional args within the calling util class
        Parameters
        ----------
        label : string
            Label of the Event, has to be unique.
        
        point : string or int
            Starting Point of the event, Value + unit (e.g. DAYS).
        
        cp : string
            title of the collection protocol.
        
        site : string
            The default Site of the event.
        
        diagnosis : string
            Defines the permissable values of the diagnosis.
        
        status : string
            Defines the permissable values of the clinical status.
        
        acitivity : string
            DEfines the activity status of the event.
        
        unit : string
            Defines which unit has the starting point.
        
        code : string
            the Event code, is optional. In order to define condionals in the workflow, one need the Event code.
        Returns
        -------
        JSON-formated string
            Returns a JSON-formated string with the given details for cp event creation
        &#34;&#34;&#34;

        params = {
            &#34;eventLabel&#34;: label,
            &#34;clinicalDiagnosis&#34;: diagnosis,
            &#34;clinicalStatus&#34;: status,
            &#34;collectionProtocol&#34;: cp,
            &#34;defaultSite&#34;: site,
            &#34;activityStatus&#34;: activity,
            &#34;eventPoint&#34;: point,
            &#34;eventPointUnit&#34;: unit
        }

        return json.dumps(params)


    def create_specimen_json(self, label=None, specimenclass=None, specimentype=None, pathology=None, anatomic=None,
                            laterality=None, initqty=None, avaqty=None, visitid=None, userid=None, colltime=None,
                            rectime=None, recqlt=None, lineage=&#39;New&#39;, status=&#39;Collected&#39;, storloc=None, concentration=None,
                            biohazard=None, comments=None,  collproc=None, conttype=None, extension =None):


        &#34;&#34;&#34;Create a API Json String for a Specimen
        Create the JSON String neccesary for creating a specimen
        
        Notes
        -----
        Mandatory paramters are passed as positional args within the calling util class
        Parameters
        ----------
        label : string
            UUID of specimen generated automatically if not set to manual in corresponding collection protocol
        
        specimenclass : string
            Class of the specimen.
        
        specimentype : string
            Type of the specimen, belongs to the class.
        
        pathology : string
            Pathologystatus of the Specimen.
        anatomic : string
            The anatomic site of the specimen.
        
        laterality : string
            The laterality of the specimen.
        
        initqty : int
            The initial quantity of a specimen.
        
        avaqty : int
            The available quantity of a specimen.
        
        visitid : int
            The unique identifier of the visit.
        recqlt : string
            The received quality.
            
        colltime : string
            Date and Time of the collection event, the format is in the OpenSpecimen&#39;s System configuration.[optional]
            
        rectime : string
            Date and Time of the received event, the format is in the OpenSpecimen&#39;s System configuration.[optional]
            
        lineage : string
            Lineage of the specimen, default value is New.
            
        status : string
            Status of the Specimen, default is &#39;Collected&#39;.
        
        stor_name : string
            Name of the container. [optional]
        
        storlocx : int
            Position of the specimen in the Container in x direction.[optional]
        storlocy : int
            Position of the specimen int the container in y direction.[optional]
            
        concetration  : int
            Concentration of the specimen[optional].
        
        biohazard : string
            Biohazards of that specimen.[optional]
        
        userid : int
            ID of the user who creates the specimen. If not specified the API user is taken.
            
        comments : string
            Comments regarding to the specimen[optional].
        
        collproc : string
            The procedure of the collection[otpional].
        conttype : string
            Type of the storage conatiner.
            
        extension : JSON-String
            JSON-formated-string containing the dict of specimnen extensions created during call to the corresponding util class 
        
        Returns
        -------
        dict
            JSON-formated-string with the complete specimen to be created
        &#34;&#34;&#34;

        data = {
            &#34;label&#34;: label,
            &#34;specimenClass&#34;: specimenclass,
            &#34;type&#34;: specimentype,
            &#34;pathology&#34;: pathology,
            &#34;anatomicSite&#34;: anatomic,
            &#34;laterality&#34;: laterality,
            &#34;initialQty&#34;: initqty,
            &#34;availableQty&#34;: avaqty,
            &#34;visitId&#34;: visitid,
            &#34;status&#34;: status,
            &#34;storageLocation&#34;: storloc,
            &#34;concetration&#34;: concentration,
            &#34;biohazard&#34;: biohazard,
            &#34;comments&#34;: comments,
            &#34;collectionEvent&#34;: {
                &#34;user&#34;: {&#34;id&#34;: userid},
                    &#34;time&#34;: colltime,
                    &#34;container&#34;: conttype,
                    &#34;procedure&#34;: collproc
                     },
            &#34;receivedEvent&#34;:{
                &#34;user&#34;:{&#34;id&#34;: userid},
                &#34;time&#34;: rectime,
                &#34;receivedQuality&#34;: recqlt
            },
            &#34;extensionDetail&#34;: extension
            }
        
        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)

    def create_extension(self, attrsmap=None, extensiondict=None, useudn=None):

        data = {
            &#34;useUdn&#34;: useudn,
            &#34;attryMap&#34;: attrsmap,
            &#34;value&#34;: extensiondict
        }

        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)
    
    # Create CSV export job  
    def create_csv_export_job(self, objecttype=None, recordids=None, cpid=None, ppids=None,  entitytype=None, formname=None, 
                            specimenlabels=None):
    
        &#34;&#34;&#34;Create JSON formated string neccesary for exporting an collection protocol (should be implemented but is not see OpenSpecimen 7.2)

        Parameters
        objecttype: string 
            Identifying the general object to be exported.
            Permissible Values: &#34;institute&#34;, &#34;site&#34;, &#34;user&#34;, &#34;cpr&#34;, &#34;specimen&#34;, &#34;extensions&#34;, &#34;storageContainer&#34;
        recordids: list or string
            Comma seperated list of record ids for fetching selected entries by their identifier. (Sites, Institutes, Users and Containers) 
        cp_id: string 
            Collection protocol id of export target not neccesary for objects higher in the hierachy like institue or site.
            For all others it can be specified or set to &#34;-1&#34; which means all data in the system.
        ppids: list or string
            List of comma seperated participant identifiers; String if its a singular participant to be exported
            Used in combination with specimen object type as a paramter
        entitytype: string
            Paramter defining the entity for data extraction (e.g.: attached form at participant level)
            used with the extension object type
        formname: string
            Defines the form to be downloaded in context of the extension object type together with the specified entity 
        specimenlabels: list or string
            List of comma seperated specimen identifiers; str if its a singular specimen to be exported        
        ----------
        Returns JSON-formated-string 
            Json data needed for creating an export job for the given entity
        -------
        &#34;&#34;&#34;
        object_types = [&#34;institute&#34;, &#34;site&#34;, &#34;user&#34;, &#34;cpr&#34;, &#34;specimen&#34;, &#34;extensions&#34;, &#34;storageContainer&#34;, &#34;distributionProtocol&#34;, &#34;cp&#34;, &#34;cpe&#34;]
        entity_types = [&#34;Participant&#34;, &#34;Visit&#34;, &#34;Specimen&#34;, &#34;SpecimenEvent&#34;, &#34;SpecimenCollectionGroup&#34;, &#34;CollectionProtocol&#34;]
        objecttype = objecttype.lower()
        
        assert objecttype in object_types, &#34;Object Type {} not allowed check documentation&#34;.format(objecttype)
        if entitytype is not None:
            assert entitytype in entity_types, &#34;Entity Type {} not allowed check documentation&#34;.format(entitytype)
        
        if objecttype == &#34;cpr&#34; or objecttype == &#34;specimen&#34;:
            assert cpid is not None , &#34;cpid may not be none with objecttype {}&#34;.format(objecttype)
        elif objecttype == &#34;extensions&#34;:
            assert formname is not None and entitytype is not None, &#34;Please specify formname and the entitytype the given form is attached to&#34;
            assert cpid is not None , &#34;cpid may not be none with objecttype {}&#34;.format(objecttype)

        params = {
                &#34;ppids&#34;: ppids,
                &#34;specimenLabels&#34;: specimenlabels,
                &#34;entityType&#34;: entitytype,
                &#34;formName&#34;: formname,
                &#34;cpId&#34;: cpid
            }
        params = {k: v for k, v in params.items() if v is not None}
        data = {
            &#34;objectType&#34;: objecttype,
            &#34;recordIds&#34;: recordids,
            &#34;params&#34;: params
        }
        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)
    
    # Create Any AQL Query
    def execute_aql(self, cpid, aql, rowmode=&#39;OFF&#39;, columnexpr=&#39;true&#39;, isodate=&#39;true&#39;):
        
        &#34;&#34;&#34;Create JSON formated string to execute a specified query passed to the method

        Parameters
        cp_id: string 
            Collection protocoll id of export target
        aql: string
            query command in the OpenSpecimen Syntax (see OpenSpecimen API) 
        rowmode: string
           Specifies whether multi-valued attributes result in a single row or one row per value. 
           Default value is OFF. Other permitted values are SHALLOW and DEEP. 
           Try out to see what fits best for your use case. 
        columnexpr: string 
            Specifies whether the column labels or AQL expression needs to be included in the query response. 
            By default, user friendly column labels are included in query response.     
        isodate: string
            Specifies how the date column values needs to be serialised in the query response. 
            If true, then date/time values are serialised using ISO format: yyyy-MM-dd&#39;T&#39;HH:mm:ss. 
            Otherwise, date/time values are serialised using the format specified in OS locale settings
        ----------
        Returns
        JSON-formated-string 
            Json data needed for executing a system query
        -------
        &#34;&#34;&#34;
        params = {
            &#34;cpId&#34; : cpid,
            &#34;aql&#34; : aql,
            &#34;wideRowMode&#34; : rowmode,
            &#34;outputColumnExprs&#34; : columnexpr,
            &#34;outputIsoDateTime&#34; : isodate
        }
        
        params = {k: v for k, v in params.items() if v is not None}
        return json.dumps(params)

    # Execute Saved Query
    def execute_query(self, start, results, drivingform=&#34;Participant&#34;, rowmode=&#34;OFF&#34;):
        
        &#34;&#34;&#34;Create JSON formated string neccesary for execution of a saved query
        Parameters
        start: string 
            Used for paginating the results. If start=5, the output result will start from row number 5.
        resutls: string
            Used for paginating the results. If results=10, the output result will be maximum 10 rows
        drivingform: string
            Driving form determines the search perspective. When left empty, it defaults to Participant.
            (For example when drivingForm is Participant, the root table is &#39;catissue_coll_prot_reg&#39; 
            which is then used to join with the other tables.
            Similarly when drivingForm is Specimen, the root table will be catissue_specimen, 
            which will be joined with the other tables.) rowmode: string
        ----------
        Returns
        JSON-formated-string 
            Json data needed for executing a query saved within an Openspecimen appliance
        -------
        &#34;&#34;&#34;

        params= {
            &#34;drivingForm&#34;: drivingform,
            &#34;wideRowMode&#34;: rowmode,
            &#34;startAt&#34;: start,
            &#34;maxResults&#34;:results
        }
        params = {k: v for k, v in params.items() if v is not None}
        return json.dumps(params)

    def create_bulk_import_job(self, schemaname=None, operation=None, fileid=None,
                                   dateformat=None, timeformat=None):

        &#34;&#34;&#34;Create JSON formated string neccesary for creating a bulk import operation to be handled by OpenSpecimen

        Parameters
        schemaname : string
            The Openspecimen schematype, that defines the expected CSV file structure for the entity to be created   
        operation : string
            Either CREATE or UPDATE duplicate entries will be ignored in case of creation. 
        fileid: string
            The file id created internally by OpenSpecimen, which needs to be passed to the API                      
        dateformat: string
            Specification of date format used in the OpenSpecimen API. See link for details
            https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats
        timeformat: string
            Specification of time format used in the OpenSpecimen API. See link for details
            https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats
        ----------
        Returns
        JSON-formated-string 
            Json data needed for creating an CSV file import job for the given entity
        -------
        &#34;&#34;&#34;
        
        data = {&#34;objectType&#34;: schemaname,
                    &#34;importType&#34;: operation,
                    &#34;inputFileId&#34;: fileid,
                    &#34;dateFormat&#34;:dateformat,
                    &#34;timeFormat&#34;:timeformat
                    }

        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)

    def get_registrations(self, cpid=None, registrationdate=None, ppid=None, name=None, birthdate=None, uid=None, specimen=None,
                                    includestats=None, startat=None,maxresults=None, exactmatch=None):

        &#34;&#34;&#34;Create JSON formated string neccesary for creating a bulk import operation to be handled by OpenSpecimen

        Parameters
        cpid : string
            Collection protol id of the participants to be queried
        registrationdate: string
            Date formatted string to query participants registered especially on this date
        ppid: string
            OpenSpecimen internal unique id or part of a unique id to be matched (exact matching is defind in exact match)
        name: string
            Name of the participant to be matched
        birthdate: string
            Date formatted string containing the birthdate of a particiapnt to be queried
        uid: string
            Social Security number  or different national identifier
        specimen: string
            Participants whose specimen labels or barcodes contain this parameter value as a substring will be matched
        includestats: string
            Include additional statitics within the response (visits specimens etc.)
        startat: string
            startat and maxResults are useful in implementing pagination of participants list. When not specified, 
            startAt defaults to 0. When startAt = n, the first element of the response is (n + 1)th participant satisfying the query criteria.
        maxresults: string
            This parameter specifies how many participant records should be included in the API response. 
        exactmatch: string
            Specifies whether the PPID should be exact match or sub-string match. Boolean true means exact match. Otherwise it is substring match.
        ----------
        Returns
        JSON-formated-string   trg_cp: string
            CP id of target of merge action
            Json data needed for creating an CSV file import job for the given entity
        -------
        &#34;&#34;&#34;

        params = {
            &#34;cpId&#34;: cpid,
            &#34;registrationDate&#34;: registrationdate,
            &#34;ppid&#34;: ppid,
            &#34;name&#34;: name,
            &#34;dob&#34;: birthdate,
            &#34;uid&#34;: uid,
            &#34;specimen&#34;: specimen,
            &#34;includeStats&#34;: includestats,
            &#34;startAt&#34;: startat,
            &#34;maxResults&#34;: maxresults,
            &#34;exactMatch&#34;: exactmatch
        }

        params = {k: v for k, v in params.items() if v is not None}
        return json.dumps(params)

    def add_visit_json(self, cprid, name, site, eventid=None,eventlabel=None,ppid=None, cptitle=None, cpshorttitle=None,
                        diagnosis=None, clinicalstatus=None, activity=None, visitstatus=&#34;Complete&#34;, missedreason=None,
                        missedby=None, comments=None,pathologynumber=None,cohort=None, visitdate=None, cpid=None):

    
        &#34;&#34;&#34;Create JSON formated string neccesary for adding an visit

        Parameters
        ----------
         cprid : int
            Identifier of the Collection Protocoll Registration to which the Visit belongs.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.
        
        name : string
            Name of the Visit.

        site : string
            Site to which the Visit belongs.

        eventid : int
            ID of the event to which the visit belongs.[optional]

        eventlabel : string
            Label of the event to which the visit belongs.[optional]

        ppid : string
            Identifier of the Participant to whom the Visit belongs.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

        cptitle : string
            Name of the Collection Protocol.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

        cpshorttitle : title
            Acronym of the Collection Protocol.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

        diagnosis : string
            Name of the diagnoses of the visit.

        clinicalstatus : string
            Clinical Status of the visit.[optional]

        activity : string
            Activity Status of the Visit.[optional]

        visitstatus : string
            Status of the visit.[optional]

        missedreason : string
            Reason why the visit was missed.[optional]

        missedby : string
            Details of the person who missed the visit.[optional]

        comments : string
            Commets regarding the visit.[optional]

        pathologynumber : string
            Surgical Pathology number. [optional]

        cohort : string
            Cohorts to which the Visit belongs. [optional]

        visitdate : string
            Date when the visit will occur, if empty takes the current date.[optional]

        cpid : int
            Identifier of the Collection Protocol.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

        Returns
        -------
        JSON-formatted string
            Json data necessary to add an visit via API call
        &#34;&#34;&#34;

        params = {
            &#34;cprId&#34;: cprid,
            &#34;eventId&#34;: eventid,
            &#34;eventLabel&#34;: eventlabel,
            &#34;ppid&#34;: ppid,
            &#34;cpTitle&#34;: cptitle,
            &#34;cpShortTitle&#34;:cpshorttitle,
            &#34;cpId&#34;: cpid,
            &#34;name&#34;: name,
            &#34;clinicalDiagnoses&#34;: diagnosis,
            &#34;clinicalStatus&#34;: clinicalstatus,
            &#34;activityStatus&#34;: activity,
            &#34;site&#34;: site,
            &#34;status&#34;: visitstatus,
            &#34;missedReason&#34;: missedreason,
            &#34;missedBy&#34;: missedby,
            &#34;comments&#34;: comments,
            &#34;surgicalPathologyNumber&#34;: pathologynumber,
            &#34;cohort&#34;: cohort,
            &#34;visitDate&#34;: visitdate
        }
        
        params = {k: v for k, v in params.items() if v is not None}
        return json.dumps(params)

    def storage_location_json(self, id_=None, name=None, xpos=None, ypos=None):
        
        &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

        Parameters
        ----------
        id: string
            Identifier of the Storage Container within OpenSpecimen.
        name: string
            Storage Container name
        xpos: string 
            x-coordinate within the given storage conatiner grid (if applicable) 
        ypos: string
            y-coordinate within the given storage container grid (if applicable)     
        Returns
        -------
        JSON-formated string
            JSON foramted string that is needed to retrieve the storage location of a specimen 
        &#34;&#34;&#34;
        
        data = {
            &#34;id&#34;: id_,
            &#34;name&#34;: name,
            &#34;positionX&#34;: xpos,
            &#34;positionY&#34;: ypos
        }

        data = {k: v for k, v in data.items() if v is not None}
        
        return json.dumps(data)

    def merge_cps(self, src_cp, trg_cp):
        
        &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

        Parameters
        ----------
        src_cp: string
            CP id of source collection protocoll for merge
        trg_cp: string
            CP id of target of merge action
        Returns
        -------
        JSON-formated string
            JSON-formated string neccesary for merging to CP&#39;s via API
        &#34;&#34;&#34;

        data = {
            &#34;srcCpShortTitle&#34;: src_cp,
            &#34;tgtCpShortTitle&#34;: trg_cp
        }

        return json.dumps(data)

    def create_institute(self, institutename=None, inst_id=None, get_csv = False):
        &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

        Parameters
        ----------
        institutename: string
            Name of the institute
        inst_id:
            institute_id needed for updating when creating an institute via csv
        get_csv: bool
            Return a CSV for creating an institute
        
        Returns
        -------
        JSON-formated string
            JSON-formated string neccesary for creating an institute
        &#34;&#34;&#34;

        data = {
            &#34;name&#34;: institutename
        }
        
        data = {k: v for k, v in data.items() if v is not None}
        
        if get_csv:
            data[&#34;identifier&#34;] = inst_id
            data = {k: v for k, v in data.items() if v is not None}
            return pd.DataFrame(data, index=[0]).to_csv(index=False)
        else:
            data = {k: v for k, v in data.items() if v is not None}
            return json.dumps(data)

    def get_participants(self, lastname = None, uid = None, birthdate = None, pmi = None, empi = None, reqreginfo = None):

        &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

        Parameters
        ---------
        lastname : string
            Substring of the Lastname of a Paritcipant.
        
        uid : string
            Country specific unique social security number.

        birthdate : string
            The date of registration in the format, which is defined in the System settings.
        
        pmi : dict
            Dict with details of the Medical records number mrn and the assigned site with key siteName.

        empi : string
            Enterprise wide unique ID assigned to the participant.

        reqreginfo : string
            OpenSpecimen&#39;s boolean (true/false). If true it returns details of the participant
        
        Returns
        -------
        JSON-formated string
            JSON-formated string neccesary for creating an institute
        &#34;&#34;&#34;

        
        data ={
            &#34;lastName&#34; : lastname,
            &#34;birthDate&#34; : birthdate,
            &#34;uid&#34; : uid,
            &#34;empi&#34; : empi,
            &#34;reqRegInfo&#34; : reqreginfo
        }
        if pmi==None:
            data[&#39;pmi&#39;]=None
        else:
            data[&#34;pmi&#34;]={
                &#34;mrn&#34; : str(pmi[0]),
                &#34;siteName&#34; : pmi[1]
            }

        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)


    def create_site(self, name = None, institutename = None, type_ = None, coordinators = None, address = None):

        &#34;&#34;&#34;Create a Site

        Create the payload to create a site in OpenSpecimen via API.

        Parameters
        ----------
        name : string
            String with the name of the site.
        institutename : string
            String with the name of the institute.
        type_ : string
            String with the type of the site.
        coordinators : string
            String with the login-name of the coordinators.
        address : string
            String with the address of the institute.
        site_id: string
            String with site id for upadting via csv

        Returns
        -------
        string
            JSON-formatted string to create a site such that OpenSpecimen can read it.
        &#34;&#34;&#34;
        
        data = {
            &#34;name&#34; : name,
            &#34;instituteName&#34; : institutename,
            &#34;coordinators&#34; : coordinators,
            &#34;type&#34; : type_,
            &#34;address&#34; : address
        }
            
        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)
        

    def create_user_json(self, first = None, last = None, email = None, phone = None, login = None, institute = None,
                        type_ = None, address = None, domain = None):
        
        &#34;&#34;&#34;Create User

        Create the payload for creating a user in OpenSpecimen.

        Parameters
        ----------
        first : string
            First name of the user.
        last : string
            Last name of the user.
        email : string
            Email-address of the user.
        phone : string
            Phone number of the user.
        login : string
            Login name of the user.
        institute : string
            Institute to which the user belongs.
        type_ : string
            Type of the user.
        address : string
            Address of the user.
        domain : string
            Domain where the user belongs to.

        Returns
        -------
        string
            JSON formatted string to create an user such that Openspecimen can read it
        &#34;&#34;&#34;

        data = {
            &#34;firstName&#34; : first,
            &#34;lastName&#34; : last,
            &#34;emailAddress&#34; : email,
            &#34;phoneNumber&#34; : phone,
            &#34;domainName&#34; : domain,
            &#34;loginName&#34; : login,
            &#34;instituteName&#34; : institute,
            &#34;type&#34; : type_,
            &#34;address&#34; : address
        }

        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)

    def change_user_pw_json(self, userid, newpw, oldpw = None):

        &#34;&#34;&#34;Change Password

        Change the password of an user via API.
        
        Notes
        -----
        If an user changes its one password, the old password is mandatory.
        If the user who changes the password is a superadmin, the new password is enough.

        Parameters
        ----------
        userid : int
            Integer with the unique ID of the user, which password should be changed.
        newpw : string
            String with the new password, care about the password complexity.
        oldpw : string
            String with the old password.

        Returns
        -------
        string
            JSO-formatted string  to change the password, such that OpenSpecimen can read it.
        &#34;&#34;&#34;
        
        data = {
            &#34;userId&#34; : userid,
            &#34;oldPassword&#34; : oldpw,
            &#34;newPassword&#34; : newpw
        }

        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)

    def assign_user_role_json(self, siteid, cpid, role):

        &#34;&#34;&#34;Assign Role

        Assign a Role to a Collection Protocol.

        Parameters
        ----------
        siteid : int
            Integer with the Unique ID of the site, where the User belongs.
        cpid : int
            Integer with the unique ID of the Collection protocol.
        role : string
            String with the name of the Role.

        Returns
        -------
        string
            JSON-formatted string such that OpenSpecimen can read it.
        &#34;&#34;&#34;

        data = {
            &#34;site&#34;:{&#34;id&#34;:siteid},
            &#34;collectionProtocol&#34;:{&#34;id&#34;:cpid},
            &#34;role&#34;:{&#34;name&#34;:role}
        }

        return json.dumps(data)

    def register_to_cp(self, cprid, regdate, cpid, ppid):

        &#34;&#34;&#34;Register a Registration to another Protocol

        Register an existing Registration to another Collection Protocol.

        Parameters
        ----------
        cprid : int
            Integer with the existing Registration Id of the Participant.
        regdate: string
            Dete of the Regisrtation to the new protocol.
        cpid : int
            Integer with the unique ID of the Collection Protocol.
        ppid : string
            String with the Participant protocol ID.

        Returns
        -------
        string
            Json-formatted string for register a Participant to another Protocol such that OpenSpecimen can read it.
        &#34;&#34;&#34;

        data = {
            &#34;participant&#34;:{&#34;id&#34;:cprid},
            &#34;registrationDate&#34;:regdate,
            &#34;cpId&#34;:cpid,
            &#34;ppid&#34;:ppid
        }

        return json.dumps(data)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory"><code class="flex name class">
<span>class <span class="ident">Json_factory</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Json_factory():

    def __init__(self):
        pass

    ## first approach to be overhauled
    ##TODO Decide upon way of json creation/storage for OS operations, the current idea is to set mandatory values to
    ## boolean true by default. than a random generator can create the values in fixed order and they can be set
    ## according to the boolean. Even better would be the restriction to use pandas data frames directly and create the
    ## json once data entry is done. Another important question is how to deal with custom value fields in various cases.
    ## Further, where possible, the csv import option should be used and json creation should be left to the numerous
    ## methods within Open Specimen
    # creation jsons:
    # participant
    def create_participant_json(self, regdate = None, id_ = None, cpid = None, cptitle = None, 
                        cpshorttitle =None, ppid = None, firstname = None, middlename = None, 
                        lastname = None, uid = None, birthdate = None, vitalstatus = None, 
                        deathdate = None, gender = None, race = None, ethnicities = None, cprid=None,
                        sexgenotype = None, pmis = None, mrn = None, sitename = None, empi =None):

        &#34;&#34;&#34;Creates a JSON-formated string for participant creation
        This function creates the json corresponding to the cpr_util function
        Notes
        ----- 
        Mandatory parameters are passed as positional arguments in the caliing function
        Parameters
        ----------
        regdate : string
            Mandatory field with date of registration in the format which is defined in the systemsettings of openSpecimen.
        cprid : int
            Unique ID of the Participant&#39;s Registration.
        id_ : int
            Unique ID of the Participant.
        cpid : int
            Unique ID of the Collection Protocol, which is autogenerated from OpenSpecimen. cpid or cptitle or cpshorttile is mandatory.
        
        cptitle : string
            Unique title of the Collection Protocol. cpid or cptitle or cpshorttile is mandatory.
        cpshorttitle : string
            Unique Acronym of the Collection Protocol. cpid or cptitle or cpshorttile is mandatory.
        
        ppid : string
            Participant protocol ID, is mandatory if created manaully and have to be empty if it is autogenerated.
            This is a protocol setting.
        
        firstname : string
            Participants first name.
        
        middlename : string
            Participants middle name.
        
        lastname : string
            Participants last name.
        
        uid : string
            Unique identifier e.g. social security number.
        
        birthdate : string
            Birthdate in the format which is defined in the systemsettings of OpenSpecimen.
        vitalstatus : string
            Vital status of the Participant.
        
        deathdate : string
            Deathdate in the format which is defined in the systemsettings of OpenSpecimen.
        
        gender : string
            Gender of the participant, permissable values are Male, Female, Unknown, Unspecified.
        
        race : string
            Participants racial origination, permissable values are {American Indian or Alaska Native, Asian, black or Afro American, Native Hawaiian
            or other Pacific Islander, Not REported, Unknown, White}
        
        ethnicities : string
            Participants ethnicities, permissable values are: {Hispanic or Latino, Not Hispanic or Latino, Not Reported, Unknown}
        
        sexgenotype : string
            Participants sex Genotype, permissable values are {XX Genotype, XY Genotype, XXX, Klinefelterâ€™s Syndrome, XXXY syndrome, 
            XXYY syndrome, Mosaic including XXXXY, Penta X syndrome}
        
        pmis : string
            Collection of the Participants medical record numner.
        
        mrn : string
            Participants medical record number.
        sitename : string
            Name of the site, where the participant is registrated.
        empi : string
            Enterprise master patient index number.
        Returns
        -------
        JSON-dict
            Details of the updated Participant or the OpenSpecimen error message as Dictornary.
        &#34;&#34;&#34;

        part = {
            &#34;id&#34;: id_,
            &#34;firstName&#34;: firstname,
            &#34;middleName&#34;: middlename,
            &#34;lastName&#34;: lastname,
            &#34;uid&#34;:uid,
            &#34;birthDate&#34;: birthdate,
            &#34;vitalStatus&#34;: vitalstatus,
            &#34;deathDate&#34;: deathdate,
            &#34;gender&#34;: gender,
            &#34;race&#34;: race,
            &#34;sexGenotype&#34;: sexgenotype,
            &#34;ethnicities&#34;: ethnicities,
            &#34;pmis&#34;: pmis,
            &#34;mrn&#34;: mrn,
            &#34;siteName&#34;: sitename,
            &#34;empi&#34;: empi                
        }

        part = {k: v for k, v in part.items() if v is not None}

        data = {
            &#34;cpId&#34;: str(cpid),
            &#34;registrationDate&#34;: regdate,
            &#34;ppid&#34;: str(ppid),
            &#34;cpShortTitle&#34;: cpshorttitle,
            &#34;cpTitle&#34;: cptitle
        }

        data = {k: v for k, v in data.items() if v is not None}

        data[&#39;participant&#39;]=part

        return json.dumps(data)

    # Collection Protocoll
    def create_CP_json(self, short_title = None, title=None, pi_mail=None, time_start=None, time_end=None, sites=None, man_id=False, coords=None,
                           consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                           derivativeLabelFmt =None, man_visit_name=False, man_spec_label=True, aliquots_in_same=None, activity=None,
                           aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None, cpid=None):

        &#34;&#34;&#34;Creates the JSON-formated string corresponding to the collection_protocol_util funciton create_CP
        
        Notes
        -----
        Mandatory paramters are passed as positional args within the calling util class
        Parameters
        ----------
        short_title : string
            Short title of the Collection Protocol.
        title : string
            Title of the Collection Protocol.
        pi_mail : string
            Email Address of the Principal Investigator.
        
        time_start: string
            String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
        
        time_end: string
            String with the end_time of the collection Protocol in the timeformat specified in the System configuration.
        sites: list
            Sites which are assigned to the collection Protocol.
        
        man_id : string
            OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.
        coords: dict
            dict with Coordinators and coordinator ids in it.
        consentsWaived : string
            OpenSpecimen&#39;s boolean true/false if consent should be waived.
        eth_cons_id : string
            Ethical aproavel id.
        part_no : string
            String with number of anticipated Participant count.
        desc_url = string
            URL with the decription of the Collection Protocol.
        
        visitNameFMT : string
            String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.
        man_visit_name : string
            String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
        
        man_spec_label : string
            String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
        
        activity : string
            String with the acitivity status of the Specimen.
        cpid : int
            Integer with the Unique ID of the Collection Protocol.
        
        Returns
        -------
        JSON-formated-string containing the collection protocol information neccesary for creation
        &#34;&#34;&#34;

        site_arr = []
        for item in sites:
            site_arr.append(
                
                    {&#34;siteName&#34;: item},
                
            )
        
        data = {
            &#34;id&#34;: cpid,
            &#34;shortTitle&#34;: short_title,
            &#34;title&#34;: title,
            &#34;code&#34;: None,
            &#34;principalInvestigator&#34;:
                {
                    &#34;loginName&#34;: pi_mail,
                    &#34;domain&#34;: &#34;openspecimen&#34;
                },
            &#34;startDate&#34;: time_start,
            &#34;endDate&#34;: time_end,
            &#34;ppidFmt&#34;: ppidFmt,
            &#34;manualPpidEnabled&#34;: man_id,
            &#34;cpSites&#34;: site_arr,
            &#34;consentsWaived&#34;: consentsWaived,
            &#34;irbId&#34;: eth_cons_id,
            &#34;anticipatedParticipantsCount&#34;: part_no,
            &#34;descriptionUrl&#34;: desc_url,
            &#34;specimenLabelFmt&#34;: specimenLabelFmt,
            &#34;derivativeLabelFmt&#34;: derivativeLabelFmt,
            &#34;aliquotLabelFmt&#34;: aliquotLabelFmt,
            &#34;visitNameFmt&#34;: visitNameFmt,
            &#34;manualVisitNameEnabled&#34;: man_visit_name,
            &#34;manualSpecLabelEnabled&#34;: man_spec_label,
            &#34;aliquotsInSameContainer&#34;: aliquots_in_same,
            &#34;activityStatus&#34;: activity,
            &#34;specimenCentric&#34;: specimenCentric
        }
        if coords != None:
            data[&#34;coordinators&#34;] = {&#34;loginName&#34; : coords,&#34;domain&#34; : &#34;openspecimen&#34;}

        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)

    # Collection Protocol event
    def create_cp_event_json(self, label=None, point=None, cp=None, site=None, diagnosis=None, status=None, activity=None, unit=None, code=None):
        
        &#34;&#34;&#34;Create JSON-formated string needed for event creation
        
        Create an event for a given Collection Protocol. Details of the parameters can be found in
        the parameters section.
        Notes
        -----
        Mandatory paramters are passed as positional args within the calling util class
        Parameters
        ----------
        label : string
            Label of the Event, has to be unique.
        
        point : string or int
            Starting Point of the event, Value + unit (e.g. DAYS).
        
        cp : string
            title of the collection protocol.
        
        site : string
            The default Site of the event.
        
        diagnosis : string
            Defines the permissable values of the diagnosis.
        
        status : string
            Defines the permissable values of the clinical status.
        
        acitivity : string
            DEfines the activity status of the event.
        
        unit : string
            Defines which unit has the starting point.
        
        code : string
            the Event code, is optional. In order to define condionals in the workflow, one need the Event code.
        Returns
        -------
        JSON-formated string
            Returns a JSON-formated string with the given details for cp event creation
        &#34;&#34;&#34;

        params = {
            &#34;eventLabel&#34;: label,
            &#34;clinicalDiagnosis&#34;: diagnosis,
            &#34;clinicalStatus&#34;: status,
            &#34;collectionProtocol&#34;: cp,
            &#34;defaultSite&#34;: site,
            &#34;activityStatus&#34;: activity,
            &#34;eventPoint&#34;: point,
            &#34;eventPointUnit&#34;: unit
        }

        return json.dumps(params)


    def create_specimen_json(self, label=None, specimenclass=None, specimentype=None, pathology=None, anatomic=None,
                            laterality=None, initqty=None, avaqty=None, visitid=None, userid=None, colltime=None,
                            rectime=None, recqlt=None, lineage=&#39;New&#39;, status=&#39;Collected&#39;, storloc=None, concentration=None,
                            biohazard=None, comments=None,  collproc=None, conttype=None, extension =None):


        &#34;&#34;&#34;Create a API Json String for a Specimen
        Create the JSON String neccesary for creating a specimen
        
        Notes
        -----
        Mandatory paramters are passed as positional args within the calling util class
        Parameters
        ----------
        label : string
            UUID of specimen generated automatically if not set to manual in corresponding collection protocol
        
        specimenclass : string
            Class of the specimen.
        
        specimentype : string
            Type of the specimen, belongs to the class.
        
        pathology : string
            Pathologystatus of the Specimen.
        anatomic : string
            The anatomic site of the specimen.
        
        laterality : string
            The laterality of the specimen.
        
        initqty : int
            The initial quantity of a specimen.
        
        avaqty : int
            The available quantity of a specimen.
        
        visitid : int
            The unique identifier of the visit.
        recqlt : string
            The received quality.
            
        colltime : string
            Date and Time of the collection event, the format is in the OpenSpecimen&#39;s System configuration.[optional]
            
        rectime : string
            Date and Time of the received event, the format is in the OpenSpecimen&#39;s System configuration.[optional]
            
        lineage : string
            Lineage of the specimen, default value is New.
            
        status : string
            Status of the Specimen, default is &#39;Collected&#39;.
        
        stor_name : string
            Name of the container. [optional]
        
        storlocx : int
            Position of the specimen in the Container in x direction.[optional]
        storlocy : int
            Position of the specimen int the container in y direction.[optional]
            
        concetration  : int
            Concentration of the specimen[optional].
        
        biohazard : string
            Biohazards of that specimen.[optional]
        
        userid : int
            ID of the user who creates the specimen. If not specified the API user is taken.
            
        comments : string
            Comments regarding to the specimen[optional].
        
        collproc : string
            The procedure of the collection[otpional].
        conttype : string
            Type of the storage conatiner.
            
        extension : JSON-String
            JSON-formated-string containing the dict of specimnen extensions created during call to the corresponding util class 
        
        Returns
        -------
        dict
            JSON-formated-string with the complete specimen to be created
        &#34;&#34;&#34;

        data = {
            &#34;label&#34;: label,
            &#34;specimenClass&#34;: specimenclass,
            &#34;type&#34;: specimentype,
            &#34;pathology&#34;: pathology,
            &#34;anatomicSite&#34;: anatomic,
            &#34;laterality&#34;: laterality,
            &#34;initialQty&#34;: initqty,
            &#34;availableQty&#34;: avaqty,
            &#34;visitId&#34;: visitid,
            &#34;status&#34;: status,
            &#34;storageLocation&#34;: storloc,
            &#34;concetration&#34;: concentration,
            &#34;biohazard&#34;: biohazard,
            &#34;comments&#34;: comments,
            &#34;collectionEvent&#34;: {
                &#34;user&#34;: {&#34;id&#34;: userid},
                    &#34;time&#34;: colltime,
                    &#34;container&#34;: conttype,
                    &#34;procedure&#34;: collproc
                     },
            &#34;receivedEvent&#34;:{
                &#34;user&#34;:{&#34;id&#34;: userid},
                &#34;time&#34;: rectime,
                &#34;receivedQuality&#34;: recqlt
            },
            &#34;extensionDetail&#34;: extension
            }
        
        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)

    def create_extension(self, attrsmap=None, extensiondict=None, useudn=None):

        data = {
            &#34;useUdn&#34;: useudn,
            &#34;attryMap&#34;: attrsmap,
            &#34;value&#34;: extensiondict
        }

        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)
    
    # Create CSV export job  
    def create_csv_export_job(self, objecttype=None, recordids=None, cpid=None, ppids=None,  entitytype=None, formname=None, 
                            specimenlabels=None):
    
        &#34;&#34;&#34;Create JSON formated string neccesary for exporting an collection protocol (should be implemented but is not see OpenSpecimen 7.2)

        Parameters
        objecttype: string 
            Identifying the general object to be exported.
            Permissible Values: &#34;institute&#34;, &#34;site&#34;, &#34;user&#34;, &#34;cpr&#34;, &#34;specimen&#34;, &#34;extensions&#34;, &#34;storageContainer&#34;
        recordids: list or string
            Comma seperated list of record ids for fetching selected entries by their identifier. (Sites, Institutes, Users and Containers) 
        cp_id: string 
            Collection protocol id of export target not neccesary for objects higher in the hierachy like institue or site.
            For all others it can be specified or set to &#34;-1&#34; which means all data in the system.
        ppids: list or string
            List of comma seperated participant identifiers; String if its a singular participant to be exported
            Used in combination with specimen object type as a paramter
        entitytype: string
            Paramter defining the entity for data extraction (e.g.: attached form at participant level)
            used with the extension object type
        formname: string
            Defines the form to be downloaded in context of the extension object type together with the specified entity 
        specimenlabels: list or string
            List of comma seperated specimen identifiers; str if its a singular specimen to be exported        
        ----------
        Returns JSON-formated-string 
            Json data needed for creating an export job for the given entity
        -------
        &#34;&#34;&#34;
        object_types = [&#34;institute&#34;, &#34;site&#34;, &#34;user&#34;, &#34;cpr&#34;, &#34;specimen&#34;, &#34;extensions&#34;, &#34;storageContainer&#34;, &#34;distributionProtocol&#34;, &#34;cp&#34;, &#34;cpe&#34;]
        entity_types = [&#34;Participant&#34;, &#34;Visit&#34;, &#34;Specimen&#34;, &#34;SpecimenEvent&#34;, &#34;SpecimenCollectionGroup&#34;, &#34;CollectionProtocol&#34;]
        objecttype = objecttype.lower()
        
        assert objecttype in object_types, &#34;Object Type {} not allowed check documentation&#34;.format(objecttype)
        if entitytype is not None:
            assert entitytype in entity_types, &#34;Entity Type {} not allowed check documentation&#34;.format(entitytype)
        
        if objecttype == &#34;cpr&#34; or objecttype == &#34;specimen&#34;:
            assert cpid is not None , &#34;cpid may not be none with objecttype {}&#34;.format(objecttype)
        elif objecttype == &#34;extensions&#34;:
            assert formname is not None and entitytype is not None, &#34;Please specify formname and the entitytype the given form is attached to&#34;
            assert cpid is not None , &#34;cpid may not be none with objecttype {}&#34;.format(objecttype)

        params = {
                &#34;ppids&#34;: ppids,
                &#34;specimenLabels&#34;: specimenlabels,
                &#34;entityType&#34;: entitytype,
                &#34;formName&#34;: formname,
                &#34;cpId&#34;: cpid
            }
        params = {k: v for k, v in params.items() if v is not None}
        data = {
            &#34;objectType&#34;: objecttype,
            &#34;recordIds&#34;: recordids,
            &#34;params&#34;: params
        }
        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)
    
    # Create Any AQL Query
    def execute_aql(self, cpid, aql, rowmode=&#39;OFF&#39;, columnexpr=&#39;true&#39;, isodate=&#39;true&#39;):
        
        &#34;&#34;&#34;Create JSON formated string to execute a specified query passed to the method

        Parameters
        cp_id: string 
            Collection protocoll id of export target
        aql: string
            query command in the OpenSpecimen Syntax (see OpenSpecimen API) 
        rowmode: string
           Specifies whether multi-valued attributes result in a single row or one row per value. 
           Default value is OFF. Other permitted values are SHALLOW and DEEP. 
           Try out to see what fits best for your use case. 
        columnexpr: string 
            Specifies whether the column labels or AQL expression needs to be included in the query response. 
            By default, user friendly column labels are included in query response.     
        isodate: string
            Specifies how the date column values needs to be serialised in the query response. 
            If true, then date/time values are serialised using ISO format: yyyy-MM-dd&#39;T&#39;HH:mm:ss. 
            Otherwise, date/time values are serialised using the format specified in OS locale settings
        ----------
        Returns
        JSON-formated-string 
            Json data needed for executing a system query
        -------
        &#34;&#34;&#34;
        params = {
            &#34;cpId&#34; : cpid,
            &#34;aql&#34; : aql,
            &#34;wideRowMode&#34; : rowmode,
            &#34;outputColumnExprs&#34; : columnexpr,
            &#34;outputIsoDateTime&#34; : isodate
        }
        
        params = {k: v for k, v in params.items() if v is not None}
        return json.dumps(params)

    # Execute Saved Query
    def execute_query(self, start, results, drivingform=&#34;Participant&#34;, rowmode=&#34;OFF&#34;):
        
        &#34;&#34;&#34;Create JSON formated string neccesary for execution of a saved query
        Parameters
        start: string 
            Used for paginating the results. If start=5, the output result will start from row number 5.
        resutls: string
            Used for paginating the results. If results=10, the output result will be maximum 10 rows
        drivingform: string
            Driving form determines the search perspective. When left empty, it defaults to Participant.
            (For example when drivingForm is Participant, the root table is &#39;catissue_coll_prot_reg&#39; 
            which is then used to join with the other tables.
            Similarly when drivingForm is Specimen, the root table will be catissue_specimen, 
            which will be joined with the other tables.) rowmode: string
        ----------
        Returns
        JSON-formated-string 
            Json data needed for executing a query saved within an Openspecimen appliance
        -------
        &#34;&#34;&#34;

        params= {
            &#34;drivingForm&#34;: drivingform,
            &#34;wideRowMode&#34;: rowmode,
            &#34;startAt&#34;: start,
            &#34;maxResults&#34;:results
        }
        params = {k: v for k, v in params.items() if v is not None}
        return json.dumps(params)

    def create_bulk_import_job(self, schemaname=None, operation=None, fileid=None,
                                   dateformat=None, timeformat=None):

        &#34;&#34;&#34;Create JSON formated string neccesary for creating a bulk import operation to be handled by OpenSpecimen

        Parameters
        schemaname : string
            The Openspecimen schematype, that defines the expected CSV file structure for the entity to be created   
        operation : string
            Either CREATE or UPDATE duplicate entries will be ignored in case of creation. 
        fileid: string
            The file id created internally by OpenSpecimen, which needs to be passed to the API                      
        dateformat: string
            Specification of date format used in the OpenSpecimen API. See link for details
            https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats
        timeformat: string
            Specification of time format used in the OpenSpecimen API. See link for details
            https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats
        ----------
        Returns
        JSON-formated-string 
            Json data needed for creating an CSV file import job for the given entity
        -------
        &#34;&#34;&#34;
        
        data = {&#34;objectType&#34;: schemaname,
                    &#34;importType&#34;: operation,
                    &#34;inputFileId&#34;: fileid,
                    &#34;dateFormat&#34;:dateformat,
                    &#34;timeFormat&#34;:timeformat
                    }

        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)

    def get_registrations(self, cpid=None, registrationdate=None, ppid=None, name=None, birthdate=None, uid=None, specimen=None,
                                    includestats=None, startat=None,maxresults=None, exactmatch=None):

        &#34;&#34;&#34;Create JSON formated string neccesary for creating a bulk import operation to be handled by OpenSpecimen

        Parameters
        cpid : string
            Collection protol id of the participants to be queried
        registrationdate: string
            Date formatted string to query participants registered especially on this date
        ppid: string
            OpenSpecimen internal unique id or part of a unique id to be matched (exact matching is defind in exact match)
        name: string
            Name of the participant to be matched
        birthdate: string
            Date formatted string containing the birthdate of a particiapnt to be queried
        uid: string
            Social Security number  or different national identifier
        specimen: string
            Participants whose specimen labels or barcodes contain this parameter value as a substring will be matched
        includestats: string
            Include additional statitics within the response (visits specimens etc.)
        startat: string
            startat and maxResults are useful in implementing pagination of participants list. When not specified, 
            startAt defaults to 0. When startAt = n, the first element of the response is (n + 1)th participant satisfying the query criteria.
        maxresults: string
            This parameter specifies how many participant records should be included in the API response. 
        exactmatch: string
            Specifies whether the PPID should be exact match or sub-string match. Boolean true means exact match. Otherwise it is substring match.
        ----------
        Returns
        JSON-formated-string   trg_cp: string
            CP id of target of merge action
            Json data needed for creating an CSV file import job for the given entity
        -------
        &#34;&#34;&#34;

        params = {
            &#34;cpId&#34;: cpid,
            &#34;registrationDate&#34;: registrationdate,
            &#34;ppid&#34;: ppid,
            &#34;name&#34;: name,
            &#34;dob&#34;: birthdate,
            &#34;uid&#34;: uid,
            &#34;specimen&#34;: specimen,
            &#34;includeStats&#34;: includestats,
            &#34;startAt&#34;: startat,
            &#34;maxResults&#34;: maxresults,
            &#34;exactMatch&#34;: exactmatch
        }

        params = {k: v for k, v in params.items() if v is not None}
        return json.dumps(params)

    def add_visit_json(self, cprid, name, site, eventid=None,eventlabel=None,ppid=None, cptitle=None, cpshorttitle=None,
                        diagnosis=None, clinicalstatus=None, activity=None, visitstatus=&#34;Complete&#34;, missedreason=None,
                        missedby=None, comments=None,pathologynumber=None,cohort=None, visitdate=None, cpid=None):

    
        &#34;&#34;&#34;Create JSON formated string neccesary for adding an visit

        Parameters
        ----------
         cprid : int
            Identifier of the Collection Protocoll Registration to which the Visit belongs.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.
        
        name : string
            Name of the Visit.

        site : string
            Site to which the Visit belongs.

        eventid : int
            ID of the event to which the visit belongs.[optional]

        eventlabel : string
            Label of the event to which the visit belongs.[optional]

        ppid : string
            Identifier of the Participant to whom the Visit belongs.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

        cptitle : string
            Name of the Collection Protocol.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

        cpshorttitle : title
            Acronym of the Collection Protocol.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

        diagnosis : string
            Name of the diagnoses of the visit.

        clinicalstatus : string
            Clinical Status of the visit.[optional]

        activity : string
            Activity Status of the Visit.[optional]

        visitstatus : string
            Status of the visit.[optional]

        missedreason : string
            Reason why the visit was missed.[optional]

        missedby : string
            Details of the person who missed the visit.[optional]

        comments : string
            Commets regarding the visit.[optional]

        pathologynumber : string
            Surgical Pathology number. [optional]

        cohort : string
            Cohorts to which the Visit belongs. [optional]

        visitdate : string
            Date when the visit will occur, if empty takes the current date.[optional]

        cpid : int
            Identifier of the Collection Protocol.
            cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

        Returns
        -------
        JSON-formatted string
            Json data necessary to add an visit via API call
        &#34;&#34;&#34;

        params = {
            &#34;cprId&#34;: cprid,
            &#34;eventId&#34;: eventid,
            &#34;eventLabel&#34;: eventlabel,
            &#34;ppid&#34;: ppid,
            &#34;cpTitle&#34;: cptitle,
            &#34;cpShortTitle&#34;:cpshorttitle,
            &#34;cpId&#34;: cpid,
            &#34;name&#34;: name,
            &#34;clinicalDiagnoses&#34;: diagnosis,
            &#34;clinicalStatus&#34;: clinicalstatus,
            &#34;activityStatus&#34;: activity,
            &#34;site&#34;: site,
            &#34;status&#34;: visitstatus,
            &#34;missedReason&#34;: missedreason,
            &#34;missedBy&#34;: missedby,
            &#34;comments&#34;: comments,
            &#34;surgicalPathologyNumber&#34;: pathologynumber,
            &#34;cohort&#34;: cohort,
            &#34;visitDate&#34;: visitdate
        }
        
        params = {k: v for k, v in params.items() if v is not None}
        return json.dumps(params)

    def storage_location_json(self, id_=None, name=None, xpos=None, ypos=None):
        
        &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

        Parameters
        ----------
        id: string
            Identifier of the Storage Container within OpenSpecimen.
        name: string
            Storage Container name
        xpos: string 
            x-coordinate within the given storage conatiner grid (if applicable) 
        ypos: string
            y-coordinate within the given storage container grid (if applicable)     
        Returns
        -------
        JSON-formated string
            JSON foramted string that is needed to retrieve the storage location of a specimen 
        &#34;&#34;&#34;
        
        data = {
            &#34;id&#34;: id_,
            &#34;name&#34;: name,
            &#34;positionX&#34;: xpos,
            &#34;positionY&#34;: ypos
        }

        data = {k: v for k, v in data.items() if v is not None}
        
        return json.dumps(data)

    def merge_cps(self, src_cp, trg_cp):
        
        &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

        Parameters
        ----------
        src_cp: string
            CP id of source collection protocoll for merge
        trg_cp: string
            CP id of target of merge action
        Returns
        -------
        JSON-formated string
            JSON-formated string neccesary for merging to CP&#39;s via API
        &#34;&#34;&#34;

        data = {
            &#34;srcCpShortTitle&#34;: src_cp,
            &#34;tgtCpShortTitle&#34;: trg_cp
        }

        return json.dumps(data)

    def create_institute(self, institutename=None, inst_id=None, get_csv = False):
        &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

        Parameters
        ----------
        institutename: string
            Name of the institute
        inst_id:
            institute_id needed for updating when creating an institute via csv
        get_csv: bool
            Return a CSV for creating an institute
        
        Returns
        -------
        JSON-formated string
            JSON-formated string neccesary for creating an institute
        &#34;&#34;&#34;

        data = {
            &#34;name&#34;: institutename
        }
        
        data = {k: v for k, v in data.items() if v is not None}
        
        if get_csv:
            data[&#34;identifier&#34;] = inst_id
            data = {k: v for k, v in data.items() if v is not None}
            return pd.DataFrame(data, index=[0]).to_csv(index=False)
        else:
            data = {k: v for k, v in data.items() if v is not None}
            return json.dumps(data)

    def get_participants(self, lastname = None, uid = None, birthdate = None, pmi = None, empi = None, reqreginfo = None):

        &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

        Parameters
        ---------
        lastname : string
            Substring of the Lastname of a Paritcipant.
        
        uid : string
            Country specific unique social security number.

        birthdate : string
            The date of registration in the format, which is defined in the System settings.
        
        pmi : dict
            Dict with details of the Medical records number mrn and the assigned site with key siteName.

        empi : string
            Enterprise wide unique ID assigned to the participant.

        reqreginfo : string
            OpenSpecimen&#39;s boolean (true/false). If true it returns details of the participant
        
        Returns
        -------
        JSON-formated string
            JSON-formated string neccesary for creating an institute
        &#34;&#34;&#34;

        
        data ={
            &#34;lastName&#34; : lastname,
            &#34;birthDate&#34; : birthdate,
            &#34;uid&#34; : uid,
            &#34;empi&#34; : empi,
            &#34;reqRegInfo&#34; : reqreginfo
        }
        if pmi==None:
            data[&#39;pmi&#39;]=None
        else:
            data[&#34;pmi&#34;]={
                &#34;mrn&#34; : str(pmi[0]),
                &#34;siteName&#34; : pmi[1]
            }

        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)


    def create_site(self, name = None, institutename = None, type_ = None, coordinators = None, address = None):

        &#34;&#34;&#34;Create a Site

        Create the payload to create a site in OpenSpecimen via API.

        Parameters
        ----------
        name : string
            String with the name of the site.
        institutename : string
            String with the name of the institute.
        type_ : string
            String with the type of the site.
        coordinators : string
            String with the login-name of the coordinators.
        address : string
            String with the address of the institute.
        site_id: string
            String with site id for upadting via csv

        Returns
        -------
        string
            JSON-formatted string to create a site such that OpenSpecimen can read it.
        &#34;&#34;&#34;
        
        data = {
            &#34;name&#34; : name,
            &#34;instituteName&#34; : institutename,
            &#34;coordinators&#34; : coordinators,
            &#34;type&#34; : type_,
            &#34;address&#34; : address
        }
            
        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)
        

    def create_user_json(self, first = None, last = None, email = None, phone = None, login = None, institute = None,
                        type_ = None, address = None, domain = None):
        
        &#34;&#34;&#34;Create User

        Create the payload for creating a user in OpenSpecimen.

        Parameters
        ----------
        first : string
            First name of the user.
        last : string
            Last name of the user.
        email : string
            Email-address of the user.
        phone : string
            Phone number of the user.
        login : string
            Login name of the user.
        institute : string
            Institute to which the user belongs.
        type_ : string
            Type of the user.
        address : string
            Address of the user.
        domain : string
            Domain where the user belongs to.

        Returns
        -------
        string
            JSON formatted string to create an user such that Openspecimen can read it
        &#34;&#34;&#34;

        data = {
            &#34;firstName&#34; : first,
            &#34;lastName&#34; : last,
            &#34;emailAddress&#34; : email,
            &#34;phoneNumber&#34; : phone,
            &#34;domainName&#34; : domain,
            &#34;loginName&#34; : login,
            &#34;instituteName&#34; : institute,
            &#34;type&#34; : type_,
            &#34;address&#34; : address
        }

        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)

    def change_user_pw_json(self, userid, newpw, oldpw = None):

        &#34;&#34;&#34;Change Password

        Change the password of an user via API.
        
        Notes
        -----
        If an user changes its one password, the old password is mandatory.
        If the user who changes the password is a superadmin, the new password is enough.

        Parameters
        ----------
        userid : int
            Integer with the unique ID of the user, which password should be changed.
        newpw : string
            String with the new password, care about the password complexity.
        oldpw : string
            String with the old password.

        Returns
        -------
        string
            JSO-formatted string  to change the password, such that OpenSpecimen can read it.
        &#34;&#34;&#34;
        
        data = {
            &#34;userId&#34; : userid,
            &#34;oldPassword&#34; : oldpw,
            &#34;newPassword&#34; : newpw
        }

        data = {k: v for k, v in data.items() if v is not None}

        return json.dumps(data)

    def assign_user_role_json(self, siteid, cpid, role):

        &#34;&#34;&#34;Assign Role

        Assign a Role to a Collection Protocol.

        Parameters
        ----------
        siteid : int
            Integer with the Unique ID of the site, where the User belongs.
        cpid : int
            Integer with the unique ID of the Collection protocol.
        role : string
            String with the name of the Role.

        Returns
        -------
        string
            JSON-formatted string such that OpenSpecimen can read it.
        &#34;&#34;&#34;

        data = {
            &#34;site&#34;:{&#34;id&#34;:siteid},
            &#34;collectionProtocol&#34;:{&#34;id&#34;:cpid},
            &#34;role&#34;:{&#34;name&#34;:role}
        }

        return json.dumps(data)

    def register_to_cp(self, cprid, regdate, cpid, ppid):

        &#34;&#34;&#34;Register a Registration to another Protocol

        Register an existing Registration to another Collection Protocol.

        Parameters
        ----------
        cprid : int
            Integer with the existing Registration Id of the Participant.
        regdate: string
            Dete of the Regisrtation to the new protocol.
        cpid : int
            Integer with the unique ID of the Collection Protocol.
        ppid : string
            String with the Participant protocol ID.

        Returns
        -------
        string
            Json-formatted string for register a Participant to another Protocol such that OpenSpecimen can read it.
        &#34;&#34;&#34;

        data = {
            &#34;participant&#34;:{&#34;id&#34;:cprid},
            &#34;registrationDate&#34;:regdate,
            &#34;cpId&#34;:cpid,
            &#34;ppid&#34;:ppid
        }

        return json.dumps(data)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.add_visit_json"><code class="name flex">
<span>def <span class="ident">add_visit_json</span></span>(<span>self, cprid, name, site, eventid=None, eventlabel=None, ppid=None, cptitle=None, cpshorttitle=None, diagnosis=None, clinicalstatus=None, activity=None, visitstatus='Complete', missedreason=None, missedby=None, comments=None, pathologynumber=None, cohort=None, visitdate=None, cpid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON formated string neccesary for adding an visit</p>
<h2 id="parameters">Parameters</h2>
<p>cprid : int
Identifier of the Collection Protocoll Registration to which the Visit belongs.
cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.</p>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the Visit.</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>string</code></dt>
<dd>Site to which the Visit belongs.</dd>
<dt><strong><code>eventid</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the event to which the visit belongs.[optional]</dd>
<dt><strong><code>eventlabel</code></strong> :&ensp;<code>string</code></dt>
<dd>Label of the event to which the visit belongs.[optional]</dd>
<dt><strong><code>ppid</code></strong> :&ensp;<code>string</code></dt>
<dd>Identifier of the Participant to whom the Visit belongs.
cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.</dd>
<dt><strong><code>cptitle</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the Collection Protocol.
cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.</dd>
<dt><strong><code>cpshorttitle</code></strong> :&ensp;<code>title</code></dt>
<dd>Acronym of the Collection Protocol.
cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.</dd>
<dt><strong><code>diagnosis</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the diagnoses of the visit.</dd>
<dt><strong><code>clinicalstatus</code></strong> :&ensp;<code>string</code></dt>
<dd>Clinical Status of the visit.[optional]</dd>
<dt><strong><code>activity</code></strong> :&ensp;<code>string</code></dt>
<dd>Activity Status of the Visit.[optional]</dd>
<dt><strong><code>visitstatus</code></strong> :&ensp;<code>string</code></dt>
<dd>Status of the visit.[optional]</dd>
<dt><strong><code>missedreason</code></strong> :&ensp;<code>string</code></dt>
<dd>Reason why the visit was missed.[optional]</dd>
<dt><strong><code>missedby</code></strong> :&ensp;<code>string</code></dt>
<dd>Details of the person who missed the visit.[optional]</dd>
<dt><strong><code>comments</code></strong> :&ensp;<code>string</code></dt>
<dd>Commets regarding the visit.[optional]</dd>
<dt><strong><code>pathologynumber</code></strong> :&ensp;<code>string</code></dt>
<dd>Surgical Pathology number. [optional]</dd>
<dt><strong><code>cohort</code></strong> :&ensp;<code>string</code></dt>
<dd>Cohorts to which the Visit belongs. [optional]</dd>
<dt><strong><code>visitdate</code></strong> :&ensp;<code>string</code></dt>
<dd>Date when the visit will occur, if empty takes the current date.[optional]</dd>
<dt><strong><code>cpid</code></strong> :&ensp;<code>int</code></dt>
<dd>Identifier of the Collection Protocol.
cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-formatted string</code></dt>
<dd>Json data necessary to add an visit via API call</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_visit_json(self, cprid, name, site, eventid=None,eventlabel=None,ppid=None, cptitle=None, cpshorttitle=None,
                    diagnosis=None, clinicalstatus=None, activity=None, visitstatus=&#34;Complete&#34;, missedreason=None,
                    missedby=None, comments=None,pathologynumber=None,cohort=None, visitdate=None, cpid=None):


    &#34;&#34;&#34;Create JSON formated string neccesary for adding an visit

    Parameters
    ----------
     cprid : int
        Identifier of the Collection Protocoll Registration to which the Visit belongs.
        cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.
    
    name : string
        Name of the Visit.

    site : string
        Site to which the Visit belongs.

    eventid : int
        ID of the event to which the visit belongs.[optional]

    eventlabel : string
        Label of the event to which the visit belongs.[optional]

    ppid : string
        Identifier of the Participant to whom the Visit belongs.
        cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

    cptitle : string
        Name of the Collection Protocol.
        cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

    cpshorttitle : title
        Acronym of the Collection Protocol.
        cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

    diagnosis : string
        Name of the diagnoses of the visit.

    clinicalstatus : string
        Clinical Status of the visit.[optional]

    activity : string
        Activity Status of the Visit.[optional]

    visitstatus : string
        Status of the visit.[optional]

    missedreason : string
        Reason why the visit was missed.[optional]

    missedby : string
        Details of the person who missed the visit.[optional]

    comments : string
        Commets regarding the visit.[optional]

    pathologynumber : string
        Surgical Pathology number. [optional]

    cohort : string
        Cohorts to which the Visit belongs. [optional]

    visitdate : string
        Date when the visit will occur, if empty takes the current date.[optional]

    cpid : int
        Identifier of the Collection Protocol.
        cprid or (cptitle and ppid) or (cpid and ppid) or (cpshorttitle and ppid) are mandatory.

    Returns
    -------
    JSON-formatted string
        Json data necessary to add an visit via API call
    &#34;&#34;&#34;

    params = {
        &#34;cprId&#34;: cprid,
        &#34;eventId&#34;: eventid,
        &#34;eventLabel&#34;: eventlabel,
        &#34;ppid&#34;: ppid,
        &#34;cpTitle&#34;: cptitle,
        &#34;cpShortTitle&#34;:cpshorttitle,
        &#34;cpId&#34;: cpid,
        &#34;name&#34;: name,
        &#34;clinicalDiagnoses&#34;: diagnosis,
        &#34;clinicalStatus&#34;: clinicalstatus,
        &#34;activityStatus&#34;: activity,
        &#34;site&#34;: site,
        &#34;status&#34;: visitstatus,
        &#34;missedReason&#34;: missedreason,
        &#34;missedBy&#34;: missedby,
        &#34;comments&#34;: comments,
        &#34;surgicalPathologyNumber&#34;: pathologynumber,
        &#34;cohort&#34;: cohort,
        &#34;visitDate&#34;: visitdate
    }
    
    params = {k: v for k, v in params.items() if v is not None}
    return json.dumps(params)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.assign_user_role_json"><code class="name flex">
<span>def <span class="ident">assign_user_role_json</span></span>(<span>self, siteid, cpid, role)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign Role</p>
<p>Assign a Role to a Collection Protocol.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>siteid</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer with the Unique ID of the site, where the User belongs.</dd>
<dt><strong><code>cpid</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer with the unique ID of the Collection protocol.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the name of the Role.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>JSON-formatted string such that OpenSpecimen can read it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_user_role_json(self, siteid, cpid, role):

    &#34;&#34;&#34;Assign Role

    Assign a Role to a Collection Protocol.

    Parameters
    ----------
    siteid : int
        Integer with the Unique ID of the site, where the User belongs.
    cpid : int
        Integer with the unique ID of the Collection protocol.
    role : string
        String with the name of the Role.

    Returns
    -------
    string
        JSON-formatted string such that OpenSpecimen can read it.
    &#34;&#34;&#34;

    data = {
        &#34;site&#34;:{&#34;id&#34;:siteid},
        &#34;collectionProtocol&#34;:{&#34;id&#34;:cpid},
        &#34;role&#34;:{&#34;name&#34;:role}
    }

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.change_user_pw_json"><code class="name flex">
<span>def <span class="ident">change_user_pw_json</span></span>(<span>self, userid, newpw, oldpw=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change Password</p>
<p>Change the password of an user via API.</p>
<h2 id="notes">Notes</h2>
<p>If an user changes its one password, the old password is mandatory.
If the user who changes the password is a superadmin, the new password is enough.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userid</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer with the unique ID of the user, which password should be changed.</dd>
<dt><strong><code>newpw</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the new password, care about the password complexity.</dd>
<dt><strong><code>oldpw</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the old password.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>JSO-formatted string
to change the password, such that OpenSpecimen can read it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_user_pw_json(self, userid, newpw, oldpw = None):

    &#34;&#34;&#34;Change Password

    Change the password of an user via API.
    
    Notes
    -----
    If an user changes its one password, the old password is mandatory.
    If the user who changes the password is a superadmin, the new password is enough.

    Parameters
    ----------
    userid : int
        Integer with the unique ID of the user, which password should be changed.
    newpw : string
        String with the new password, care about the password complexity.
    oldpw : string
        String with the old password.

    Returns
    -------
    string
        JSO-formatted string  to change the password, such that OpenSpecimen can read it.
    &#34;&#34;&#34;
    
    data = {
        &#34;userId&#34; : userid,
        &#34;oldPassword&#34; : oldpw,
        &#34;newPassword&#34; : newpw
    }

    data = {k: v for k, v in data.items() if v is not None}

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_CP_json"><code class="name flex">
<span>def <span class="ident">create_CP_json</span></span>(<span>self, short_title=None, title=None, pi_mail=None, time_start=None, time_end=None, sites=None, man_id=False, coords=None, consentsWaived=None, eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, derivativeLabelFmt=None, man_visit_name=False, man_spec_label=True, aliquots_in_same=None, activity=None, aliquotLabelFmt=None, ppidFmt=None, specimenCentric=None, cpid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the JSON-formated string corresponding to the collection_protocol_util funciton create_CP</p>
<h2 id="notes">Notes</h2>
<p>Mandatory paramters are passed as positional args within the calling util class
Parameters</p>
<hr>
<dl>
<dt><strong><code>short_title</code></strong> :&ensp;<code>string</code></dt>
<dd>Short title of the Collection Protocol.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code></dt>
<dd>Title of the Collection Protocol.</dd>
<dt><strong><code>pi_mail</code></strong> :&ensp;<code>string</code></dt>
<dd>Email Address of the Principal Investigator.</dd>
<dt><strong><code>time_start</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the start_time of the collection Protocol in the timeformat specified in the System configuration.</dd>
<dt><strong><code>time_end</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the end_time of the collection Protocol in the timeformat specified in the System configuration.</dd>
<dt><strong><code>sites</code></strong> :&ensp;<code>list</code></dt>
<dd>Sites which are assigned to the collection Protocol.</dd>
<dt><strong><code>man_id</code></strong> :&ensp;<code>string</code></dt>
<dd>OpenSpecimen's boolean true/false if the manual PPID creation is enabled.</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict with Coordinators and coordinator ids in it.</dd>
<dt><strong><code>consentsWaived</code></strong> :&ensp;<code>string</code></dt>
<dd>OpenSpecimen's boolean true/false if consent should be waived.</dd>
<dt><strong><code>eth_cons_id</code></strong> :&ensp;<code>string</code></dt>
<dd>Ethical aproavel id.</dd>
<dt><strong><code>part_no</code></strong> :&ensp;<code>string</code></dt>
<dd>String with number of anticipated Participant count.</dd>
</dl>
<p>desc_url = string
URL with the decription of the Collection Protocol.</p>
<dl>
<dt><strong><code>visitNameFMT</code></strong> :&ensp;<code>string</code></dt>
<dd>String which contains the OpenSpecimen's token for creating Visit Names automatically.</dd>
<dt><strong><code>man_visit_name</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Visits should be created manually.</dd>
<dt><strong><code>man_spec_label</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Specimen Labels should be created manually.</dd>
<dt><strong><code>man_spec_label</code></strong> :&ensp;<code>string</code></dt>
<dd>String with OpenSpecimen's boolean format if the Aliquotes are stored in the same Container.</dd>
<dt><strong><code>activity</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the acitivity status of the Specimen.</dd>
<dt><strong><code>cpid</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer with the Unique ID of the Collection Protocol.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-formated-string containing the collection protocol information neccesary for creation</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_CP_json(self, short_title = None, title=None, pi_mail=None, time_start=None, time_end=None, sites=None, man_id=False, coords=None,
                       consentsWaived=None,eth_cons_id=None, part_no=None, desc_url=None, visitNameFmt=None, specimenLabelFmt=None, 
                       derivativeLabelFmt =None, man_visit_name=False, man_spec_label=True, aliquots_in_same=None, activity=None,
                       aliquotLabelFmt = None, ppidFmt= None, specimenCentric = None, cpid=None):

    &#34;&#34;&#34;Creates the JSON-formated string corresponding to the collection_protocol_util funciton create_CP
    
    Notes
    -----
    Mandatory paramters are passed as positional args within the calling util class
    Parameters
    ----------
    short_title : string
        Short title of the Collection Protocol.
    title : string
        Title of the Collection Protocol.
    pi_mail : string
        Email Address of the Principal Investigator.
    
    time_start: string
        String with the start_time of the collection Protocol in the timeformat specified in the System configuration.
    
    time_end: string
        String with the end_time of the collection Protocol in the timeformat specified in the System configuration.
    sites: list
        Sites which are assigned to the collection Protocol.
    
    man_id : string
        OpenSpecimen&#39;s boolean true/false if the manual PPID creation is enabled.
    coords: dict
        dict with Coordinators and coordinator ids in it.
    consentsWaived : string
        OpenSpecimen&#39;s boolean true/false if consent should be waived.
    eth_cons_id : string
        Ethical aproavel id.
    part_no : string
        String with number of anticipated Participant count.
    desc_url = string
        URL with the decription of the Collection Protocol.
    
    visitNameFMT : string
        String which contains the OpenSpecimen&#39;s token for creating Visit Names automatically.
    man_visit_name : string
        String with OpenSpecimen&#39;s boolean format if the Visits should be created manually.
    
    man_spec_label : string
        String with OpenSpecimen&#39;s boolean format if the Specimen Labels should be created manually.
    
    man_spec_label : string
        String with OpenSpecimen&#39;s boolean format if the Aliquotes are stored in the same Container.
    
    activity : string
        String with the acitivity status of the Specimen.
    cpid : int
        Integer with the Unique ID of the Collection Protocol.
    
    Returns
    -------
    JSON-formated-string containing the collection protocol information neccesary for creation
    &#34;&#34;&#34;

    site_arr = []
    for item in sites:
        site_arr.append(
            
                {&#34;siteName&#34;: item},
            
        )
    
    data = {
        &#34;id&#34;: cpid,
        &#34;shortTitle&#34;: short_title,
        &#34;title&#34;: title,
        &#34;code&#34;: None,
        &#34;principalInvestigator&#34;:
            {
                &#34;loginName&#34;: pi_mail,
                &#34;domain&#34;: &#34;openspecimen&#34;
            },
        &#34;startDate&#34;: time_start,
        &#34;endDate&#34;: time_end,
        &#34;ppidFmt&#34;: ppidFmt,
        &#34;manualPpidEnabled&#34;: man_id,
        &#34;cpSites&#34;: site_arr,
        &#34;consentsWaived&#34;: consentsWaived,
        &#34;irbId&#34;: eth_cons_id,
        &#34;anticipatedParticipantsCount&#34;: part_no,
        &#34;descriptionUrl&#34;: desc_url,
        &#34;specimenLabelFmt&#34;: specimenLabelFmt,
        &#34;derivativeLabelFmt&#34;: derivativeLabelFmt,
        &#34;aliquotLabelFmt&#34;: aliquotLabelFmt,
        &#34;visitNameFmt&#34;: visitNameFmt,
        &#34;manualVisitNameEnabled&#34;: man_visit_name,
        &#34;manualSpecLabelEnabled&#34;: man_spec_label,
        &#34;aliquotsInSameContainer&#34;: aliquots_in_same,
        &#34;activityStatus&#34;: activity,
        &#34;specimenCentric&#34;: specimenCentric
    }
    if coords != None:
        data[&#34;coordinators&#34;] = {&#34;loginName&#34; : coords,&#34;domain&#34; : &#34;openspecimen&#34;}

    data = {k: v for k, v in data.items() if v is not None}

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_bulk_import_job"><code class="name flex">
<span>def <span class="ident">create_bulk_import_job</span></span>(<span>self, schemaname=None, operation=None, fileid=None, dateformat=None, timeformat=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON formated string neccesary for creating a bulk import operation to be handled by OpenSpecimen</p>
<p>Parameters
schemaname : string
The Openspecimen schematype, that defines the expected CSV file structure for the entity to be created <br>
operation : string
Either CREATE or UPDATE duplicate entries will be ignored in case of creation.
fileid: string
The file id created internally by OpenSpecimen, which needs to be passed to the API
<br>
dateformat: string
Specification of date format used in the OpenSpecimen API. See link for details
<a href="https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats">https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats</a>
timeformat: string
Specification of time format used in the OpenSpecimen API. See link for details
<a href="https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats">https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats</a></p>
<hr>
<p>Returns
JSON-formated-string
Json data needed for creating an CSV file import job for the given entity</p>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_bulk_import_job(self, schemaname=None, operation=None, fileid=None,
                               dateformat=None, timeformat=None):

    &#34;&#34;&#34;Create JSON formated string neccesary for creating a bulk import operation to be handled by OpenSpecimen

    Parameters
    schemaname : string
        The Openspecimen schematype, that defines the expected CSV file structure for the entity to be created   
    operation : string
        Either CREATE or UPDATE duplicate entries will be ignored in case of creation. 
    fileid: string
        The file id created internally by OpenSpecimen, which needs to be passed to the API                      
    dateformat: string
        Specification of date format used in the OpenSpecimen API. See link for details
        https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats
    timeformat: string
        Specification of time format used in the OpenSpecimen API. See link for details
        https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/68976690/Date+and+time+formats
    ----------
    Returns
    JSON-formated-string 
        Json data needed for creating an CSV file import job for the given entity
    -------
    &#34;&#34;&#34;
    
    data = {&#34;objectType&#34;: schemaname,
                &#34;importType&#34;: operation,
                &#34;inputFileId&#34;: fileid,
                &#34;dateFormat&#34;:dateformat,
                &#34;timeFormat&#34;:timeformat
                }

    data = {k: v for k, v in data.items() if v is not None}
    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_cp_event_json"><code class="name flex">
<span>def <span class="ident">create_cp_event_json</span></span>(<span>self, label=None, point=None, cp=None, site=None, diagnosis=None, status=None, activity=None, unit=None, code=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON-formated string needed for event creation</p>
<p>Create an event for a given Collection Protocol. Details of the parameters can be found in
the parameters section.
Notes</p>
<hr>
<p>Mandatory paramters are passed as positional args within the calling util class
Parameters</p>
<hr>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code></dt>
<dd>Label of the Event, has to be unique.</dd>
<dt><strong><code>point</code></strong> :&ensp;<code>string</code> or <code>int</code></dt>
<dd>Starting Point of the event, Value + unit (e.g. DAYS).</dd>
<dt><strong><code>cp</code></strong> :&ensp;<code>string</code></dt>
<dd>title of the collection protocol.</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>string</code></dt>
<dd>The default Site of the event.</dd>
<dt><strong><code>diagnosis</code></strong> :&ensp;<code>string</code></dt>
<dd>Defines the permissable values of the diagnosis.</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>string</code></dt>
<dd>Defines the permissable values of the clinical status.</dd>
<dt><strong><code>acitivity</code></strong> :&ensp;<code>string</code></dt>
<dd>DEfines the activity status of the event.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Defines which unit has the starting point.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>string</code></dt>
<dd>the Event code, is optional. In order to define condionals in the workflow, one need the Event code.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-formated string</code></dt>
<dd>Returns a JSON-formated string with the given details for cp event creation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cp_event_json(self, label=None, point=None, cp=None, site=None, diagnosis=None, status=None, activity=None, unit=None, code=None):
    
    &#34;&#34;&#34;Create JSON-formated string needed for event creation
    
    Create an event for a given Collection Protocol. Details of the parameters can be found in
    the parameters section.
    Notes
    -----
    Mandatory paramters are passed as positional args within the calling util class
    Parameters
    ----------
    label : string
        Label of the Event, has to be unique.
    
    point : string or int
        Starting Point of the event, Value + unit (e.g. DAYS).
    
    cp : string
        title of the collection protocol.
    
    site : string
        The default Site of the event.
    
    diagnosis : string
        Defines the permissable values of the diagnosis.
    
    status : string
        Defines the permissable values of the clinical status.
    
    acitivity : string
        DEfines the activity status of the event.
    
    unit : string
        Defines which unit has the starting point.
    
    code : string
        the Event code, is optional. In order to define condionals in the workflow, one need the Event code.
    Returns
    -------
    JSON-formated string
        Returns a JSON-formated string with the given details for cp event creation
    &#34;&#34;&#34;

    params = {
        &#34;eventLabel&#34;: label,
        &#34;clinicalDiagnosis&#34;: diagnosis,
        &#34;clinicalStatus&#34;: status,
        &#34;collectionProtocol&#34;: cp,
        &#34;defaultSite&#34;: site,
        &#34;activityStatus&#34;: activity,
        &#34;eventPoint&#34;: point,
        &#34;eventPointUnit&#34;: unit
    }

    return json.dumps(params)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_csv_export_job"><code class="name flex">
<span>def <span class="ident">create_csv_export_job</span></span>(<span>self, objecttype=None, recordids=None, cpid=None, ppids=None, entitytype=None, formname=None, specimenlabels=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON formated string neccesary for exporting an collection protocol (should be implemented but is not see OpenSpecimen 7.2)</p>
<p>Parameters
objecttype: string
Identifying the general object to be exported.
Permissible Values: "institute", "site", "user", "cpr", "specimen", "extensions", "storageContainer"
recordids: list or string
Comma seperated list of record ids for fetching selected entries by their identifier. (Sites, Institutes, Users and Containers)
cp_id: string
Collection protocol id of export target not neccesary for objects higher in the hierachy like institue or site.
For all others it can be specified or set to "-1" which means all data in the system.
ppids: list or string
List of comma seperated participant identifiers; String if its a singular participant to be exported
Used in combination with specimen object type as a paramter
entitytype: string
Paramter defining the entity for data extraction (e.g.: attached form at participant level)
used with the extension object type
formname: string
Defines the form to be downloaded in context of the extension object type together with the specified entity
specimenlabels: list or string
List of comma seperated specimen identifiers; str if its a singular specimen to be exported
</p>
<hr>
<p>Returns JSON-formated-string
Json data needed for creating an export job for the given entity</p>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_csv_export_job(self, objecttype=None, recordids=None, cpid=None, ppids=None,  entitytype=None, formname=None, 
                        specimenlabels=None):

    &#34;&#34;&#34;Create JSON formated string neccesary for exporting an collection protocol (should be implemented but is not see OpenSpecimen 7.2)

    Parameters
    objecttype: string 
        Identifying the general object to be exported.
        Permissible Values: &#34;institute&#34;, &#34;site&#34;, &#34;user&#34;, &#34;cpr&#34;, &#34;specimen&#34;, &#34;extensions&#34;, &#34;storageContainer&#34;
    recordids: list or string
        Comma seperated list of record ids for fetching selected entries by their identifier. (Sites, Institutes, Users and Containers) 
    cp_id: string 
        Collection protocol id of export target not neccesary for objects higher in the hierachy like institue or site.
        For all others it can be specified or set to &#34;-1&#34; which means all data in the system.
    ppids: list or string
        List of comma seperated participant identifiers; String if its a singular participant to be exported
        Used in combination with specimen object type as a paramter
    entitytype: string
        Paramter defining the entity for data extraction (e.g.: attached form at participant level)
        used with the extension object type
    formname: string
        Defines the form to be downloaded in context of the extension object type together with the specified entity 
    specimenlabels: list or string
        List of comma seperated specimen identifiers; str if its a singular specimen to be exported        
    ----------
    Returns JSON-formated-string 
        Json data needed for creating an export job for the given entity
    -------
    &#34;&#34;&#34;
    object_types = [&#34;institute&#34;, &#34;site&#34;, &#34;user&#34;, &#34;cpr&#34;, &#34;specimen&#34;, &#34;extensions&#34;, &#34;storageContainer&#34;, &#34;distributionProtocol&#34;, &#34;cp&#34;, &#34;cpe&#34;]
    entity_types = [&#34;Participant&#34;, &#34;Visit&#34;, &#34;Specimen&#34;, &#34;SpecimenEvent&#34;, &#34;SpecimenCollectionGroup&#34;, &#34;CollectionProtocol&#34;]
    objecttype = objecttype.lower()
    
    assert objecttype in object_types, &#34;Object Type {} not allowed check documentation&#34;.format(objecttype)
    if entitytype is not None:
        assert entitytype in entity_types, &#34;Entity Type {} not allowed check documentation&#34;.format(entitytype)
    
    if objecttype == &#34;cpr&#34; or objecttype == &#34;specimen&#34;:
        assert cpid is not None , &#34;cpid may not be none with objecttype {}&#34;.format(objecttype)
    elif objecttype == &#34;extensions&#34;:
        assert formname is not None and entitytype is not None, &#34;Please specify formname and the entitytype the given form is attached to&#34;
        assert cpid is not None , &#34;cpid may not be none with objecttype {}&#34;.format(objecttype)

    params = {
            &#34;ppids&#34;: ppids,
            &#34;specimenLabels&#34;: specimenlabels,
            &#34;entityType&#34;: entitytype,
            &#34;formName&#34;: formname,
            &#34;cpId&#34;: cpid
        }
    params = {k: v for k, v in params.items() if v is not None}
    data = {
        &#34;objectType&#34;: objecttype,
        &#34;recordIds&#34;: recordids,
        &#34;params&#34;: params
    }
    data = {k: v for k, v in data.items() if v is not None}
    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_extension"><code class="name flex">
<span>def <span class="ident">create_extension</span></span>(<span>self, attrsmap=None, extensiondict=None, useudn=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_extension(self, attrsmap=None, extensiondict=None, useudn=None):

    data = {
        &#34;useUdn&#34;: useudn,
        &#34;attryMap&#34;: attrsmap,
        &#34;value&#34;: extensiondict
    }

    data = {k: v for k, v in data.items() if v is not None}

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_institute"><code class="name flex">
<span>def <span class="ident">create_institute</span></span>(<span>self, institutename=None, inst_id=None, get_csv=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON-formatted string to neccesary to retrieve storage location via API </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>institutename</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the institute</dd>
<dt>inst_id:</dt>
<dt>institute_id needed for updating when creating an institute via csv</dt>
<dt><strong><code>get_csv</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return a CSV for creating an institute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-formated string</code></dt>
<dd>JSON-formated string neccesary for creating an institute</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_institute(self, institutename=None, inst_id=None, get_csv = False):
    &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

    Parameters
    ----------
    institutename: string
        Name of the institute
    inst_id:
        institute_id needed for updating when creating an institute via csv
    get_csv: bool
        Return a CSV for creating an institute
    
    Returns
    -------
    JSON-formated string
        JSON-formated string neccesary for creating an institute
    &#34;&#34;&#34;

    data = {
        &#34;name&#34;: institutename
    }
    
    data = {k: v for k, v in data.items() if v is not None}
    
    if get_csv:
        data[&#34;identifier&#34;] = inst_id
        data = {k: v for k, v in data.items() if v is not None}
        return pd.DataFrame(data, index=[0]).to_csv(index=False)
    else:
        data = {k: v for k, v in data.items() if v is not None}
        return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_participant_json"><code class="name flex">
<span>def <span class="ident">create_participant_json</span></span>(<span>self, regdate=None, id_=None, cpid=None, cptitle=None, cpshorttitle=None, ppid=None, firstname=None, middlename=None, lastname=None, uid=None, birthdate=None, vitalstatus=None, deathdate=None, gender=None, race=None, ethnicities=None, cprid=None, sexgenotype=None, pmis=None, mrn=None, sitename=None, empi=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a JSON-formated string for participant creation
This function creates the json corresponding to the cpr_util function
Notes</p>
<hr>
<p>Mandatory parameters are passed as positional arguments in the caliing function
Parameters</p>
<hr>
<dl>
<dt><strong><code>regdate</code></strong> :&ensp;<code>string</code></dt>
<dd>Mandatory field with date of registration in the format which is defined in the systemsettings of openSpecimen.</dd>
<dt><strong><code>cprid</code></strong> :&ensp;<code>int</code></dt>
<dd>Unique ID of the Participant's Registration.</dd>
<dt><strong><code>id_</code></strong> :&ensp;<code>int</code></dt>
<dd>Unique ID of the Participant.</dd>
<dt><strong><code>cpid</code></strong> :&ensp;<code>int</code></dt>
<dd>Unique ID of the Collection Protocol, which is autogenerated from OpenSpecimen. cpid or cptitle or cpshorttile is mandatory.</dd>
<dt><strong><code>cptitle</code></strong> :&ensp;<code>string</code></dt>
<dd>Unique title of the Collection Protocol. cpid or cptitle or cpshorttile is mandatory.</dd>
<dt><strong><code>cpshorttitle</code></strong> :&ensp;<code>string</code></dt>
<dd>Unique Acronym of the Collection Protocol. cpid or cptitle or cpshorttile is mandatory.</dd>
<dt><strong><code>ppid</code></strong> :&ensp;<code>string</code></dt>
<dd>Participant protocol ID, is mandatory if created manaully and have to be empty if it is autogenerated.
This is a protocol setting.</dd>
<dt><strong><code>firstname</code></strong> :&ensp;<code>string</code></dt>
<dd>Participants first name.</dd>
<dt><strong><code>middlename</code></strong> :&ensp;<code>string</code></dt>
<dd>Participants middle name.</dd>
<dt><strong><code>lastname</code></strong> :&ensp;<code>string</code></dt>
<dd>Participants last name.</dd>
<dt><strong><code>uid</code></strong> :&ensp;<code>string</code></dt>
<dd>Unique identifier e.g. social security number.</dd>
<dt><strong><code>birthdate</code></strong> :&ensp;<code>string</code></dt>
<dd>Birthdate in the format which is defined in the systemsettings of OpenSpecimen.</dd>
<dt><strong><code>vitalstatus</code></strong> :&ensp;<code>string</code></dt>
<dd>Vital status of the Participant.</dd>
<dt><strong><code>deathdate</code></strong> :&ensp;<code>string</code></dt>
<dd>Deathdate in the format which is defined in the systemsettings of OpenSpecimen.</dd>
<dt><strong><code>gender</code></strong> :&ensp;<code>string</code></dt>
<dd>Gender of the participant, permissable values are Male, Female, Unknown, Unspecified.</dd>
<dt><strong><code>race</code></strong> :&ensp;<code>string</code></dt>
<dd>Participants racial origination, permissable values are {American Indian or Alaska Native, Asian, black or Afro American, Native Hawaiian
or other Pacific Islander, Not REported, Unknown, White}</dd>
<dt><strong><code>ethnicities</code></strong> :&ensp;<code>string</code></dt>
<dd>Participants ethnicities, permissable values are: {Hispanic or Latino, Not Hispanic or Latino, Not Reported, Unknown}</dd>
<dt><strong><code>sexgenotype</code></strong> :&ensp;<code>string</code></dt>
<dd>Participants sex Genotype, permissable values are {XX Genotype, XY Genotype, XXX, Klinefelterâ€™s Syndrome, XXXY syndrome,
XXYY syndrome, Mosaic including XXXXY, Penta X syndrome}</dd>
<dt><strong><code>pmis</code></strong> :&ensp;<code>string</code></dt>
<dd>Collection of the Participants medical record numner.</dd>
<dt><strong><code>mrn</code></strong> :&ensp;<code>string</code></dt>
<dd>Participants medical record number.</dd>
<dt><strong><code>sitename</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the site, where the participant is registrated.</dd>
<dt><strong><code>empi</code></strong> :&ensp;<code>string</code></dt>
<dd>Enterprise master patient index number.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>Details of the updated Participant or the OpenSpecimen error message as Dictornary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_participant_json(self, regdate = None, id_ = None, cpid = None, cptitle = None, 
                    cpshorttitle =None, ppid = None, firstname = None, middlename = None, 
                    lastname = None, uid = None, birthdate = None, vitalstatus = None, 
                    deathdate = None, gender = None, race = None, ethnicities = None, cprid=None,
                    sexgenotype = None, pmis = None, mrn = None, sitename = None, empi =None):

    &#34;&#34;&#34;Creates a JSON-formated string for participant creation
    This function creates the json corresponding to the cpr_util function
    Notes
    ----- 
    Mandatory parameters are passed as positional arguments in the caliing function
    Parameters
    ----------
    regdate : string
        Mandatory field with date of registration in the format which is defined in the systemsettings of openSpecimen.
    cprid : int
        Unique ID of the Participant&#39;s Registration.
    id_ : int
        Unique ID of the Participant.
    cpid : int
        Unique ID of the Collection Protocol, which is autogenerated from OpenSpecimen. cpid or cptitle or cpshorttile is mandatory.
    
    cptitle : string
        Unique title of the Collection Protocol. cpid or cptitle or cpshorttile is mandatory.
    cpshorttitle : string
        Unique Acronym of the Collection Protocol. cpid or cptitle or cpshorttile is mandatory.
    
    ppid : string
        Participant protocol ID, is mandatory if created manaully and have to be empty if it is autogenerated.
        This is a protocol setting.
    
    firstname : string
        Participants first name.
    
    middlename : string
        Participants middle name.
    
    lastname : string
        Participants last name.
    
    uid : string
        Unique identifier e.g. social security number.
    
    birthdate : string
        Birthdate in the format which is defined in the systemsettings of OpenSpecimen.
    vitalstatus : string
        Vital status of the Participant.
    
    deathdate : string
        Deathdate in the format which is defined in the systemsettings of OpenSpecimen.
    
    gender : string
        Gender of the participant, permissable values are Male, Female, Unknown, Unspecified.
    
    race : string
        Participants racial origination, permissable values are {American Indian or Alaska Native, Asian, black or Afro American, Native Hawaiian
        or other Pacific Islander, Not REported, Unknown, White}
    
    ethnicities : string
        Participants ethnicities, permissable values are: {Hispanic or Latino, Not Hispanic or Latino, Not Reported, Unknown}
    
    sexgenotype : string
        Participants sex Genotype, permissable values are {XX Genotype, XY Genotype, XXX, Klinefelterâ€™s Syndrome, XXXY syndrome, 
        XXYY syndrome, Mosaic including XXXXY, Penta X syndrome}
    
    pmis : string
        Collection of the Participants medical record numner.
    
    mrn : string
        Participants medical record number.
    sitename : string
        Name of the site, where the participant is registrated.
    empi : string
        Enterprise master patient index number.
    Returns
    -------
    JSON-dict
        Details of the updated Participant or the OpenSpecimen error message as Dictornary.
    &#34;&#34;&#34;

    part = {
        &#34;id&#34;: id_,
        &#34;firstName&#34;: firstname,
        &#34;middleName&#34;: middlename,
        &#34;lastName&#34;: lastname,
        &#34;uid&#34;:uid,
        &#34;birthDate&#34;: birthdate,
        &#34;vitalStatus&#34;: vitalstatus,
        &#34;deathDate&#34;: deathdate,
        &#34;gender&#34;: gender,
        &#34;race&#34;: race,
        &#34;sexGenotype&#34;: sexgenotype,
        &#34;ethnicities&#34;: ethnicities,
        &#34;pmis&#34;: pmis,
        &#34;mrn&#34;: mrn,
        &#34;siteName&#34;: sitename,
        &#34;empi&#34;: empi                
    }

    part = {k: v for k, v in part.items() if v is not None}

    data = {
        &#34;cpId&#34;: str(cpid),
        &#34;registrationDate&#34;: regdate,
        &#34;ppid&#34;: str(ppid),
        &#34;cpShortTitle&#34;: cpshorttitle,
        &#34;cpTitle&#34;: cptitle
    }

    data = {k: v for k, v in data.items() if v is not None}

    data[&#39;participant&#39;]=part

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_site"><code class="name flex">
<span>def <span class="ident">create_site</span></span>(<span>self, name=None, institutename=None, type_=None, coordinators=None, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Site</p>
<p>Create the payload to create a site in OpenSpecimen via API.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the name of the site.</dd>
<dt><strong><code>institutename</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the name of the institute.</dd>
<dt><strong><code>type_</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the type of the site.</dd>
<dt><strong><code>coordinators</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the login-name of the coordinators.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the address of the institute.</dd>
<dt><strong><code>site_id</code></strong> :&ensp;<code>string</code></dt>
<dd>String with site id for upadting via csv</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>JSON-formatted string to create a site such that OpenSpecimen can read it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_site(self, name = None, institutename = None, type_ = None, coordinators = None, address = None):

    &#34;&#34;&#34;Create a Site

    Create the payload to create a site in OpenSpecimen via API.

    Parameters
    ----------
    name : string
        String with the name of the site.
    institutename : string
        String with the name of the institute.
    type_ : string
        String with the type of the site.
    coordinators : string
        String with the login-name of the coordinators.
    address : string
        String with the address of the institute.
    site_id: string
        String with site id for upadting via csv

    Returns
    -------
    string
        JSON-formatted string to create a site such that OpenSpecimen can read it.
    &#34;&#34;&#34;
    
    data = {
        &#34;name&#34; : name,
        &#34;instituteName&#34; : institutename,
        &#34;coordinators&#34; : coordinators,
        &#34;type&#34; : type_,
        &#34;address&#34; : address
    }
        
    data = {k: v for k, v in data.items() if v is not None}
    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_specimen_json"><code class="name flex">
<span>def <span class="ident">create_specimen_json</span></span>(<span>self, label=None, specimenclass=None, specimentype=None, pathology=None, anatomic=None, laterality=None, initqty=None, avaqty=None, visitid=None, userid=None, colltime=None, rectime=None, recqlt=None, lineage='New', status='Collected', storloc=None, concentration=None, biohazard=None, comments=None, collproc=None, conttype=None, extension=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a API Json String for a Specimen
Create the JSON String neccesary for creating a specimen</p>
<h2 id="notes">Notes</h2>
<p>Mandatory paramters are passed as positional args within the calling util class
Parameters</p>
<hr>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code></dt>
<dd>UUID of specimen generated automatically if not set to manual in corresponding collection protocol</dd>
<dt><strong><code>specimenclass</code></strong> :&ensp;<code>string</code></dt>
<dd>Class of the specimen.</dd>
<dt><strong><code>specimentype</code></strong> :&ensp;<code>string</code></dt>
<dd>Type of the specimen, belongs to the class.</dd>
<dt><strong><code>pathology</code></strong> :&ensp;<code>string</code></dt>
<dd>Pathologystatus of the Specimen.</dd>
<dt><strong><code>anatomic</code></strong> :&ensp;<code>string</code></dt>
<dd>The anatomic site of the specimen.</dd>
<dt><strong><code>laterality</code></strong> :&ensp;<code>string</code></dt>
<dd>The laterality of the specimen.</dd>
<dt><strong><code>initqty</code></strong> :&ensp;<code>int</code></dt>
<dd>The initial quantity of a specimen.</dd>
<dt><strong><code>avaqty</code></strong> :&ensp;<code>int</code></dt>
<dd>The available quantity of a specimen.</dd>
<dt><strong><code>visitid</code></strong> :&ensp;<code>int</code></dt>
<dd>The unique identifier of the visit.</dd>
<dt><strong><code>recqlt</code></strong> :&ensp;<code>string</code></dt>
<dd>The received quality.</dd>
<dt><strong><code>colltime</code></strong> :&ensp;<code>string</code></dt>
<dd>Date and Time of the collection event, the format is in the OpenSpecimen's System configuration.[optional]</dd>
<dt><strong><code>rectime</code></strong> :&ensp;<code>string</code></dt>
<dd>Date and Time of the received event, the format is in the OpenSpecimen's System configuration.[optional]</dd>
<dt><strong><code>lineage</code></strong> :&ensp;<code>string</code></dt>
<dd>Lineage of the specimen, default value is New.</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>string</code></dt>
<dd>Status of the Specimen, default is 'Collected'.</dd>
<dt><strong><code>stor_name</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the container. [optional]</dd>
<dt><strong><code>storlocx</code></strong> :&ensp;<code>int</code></dt>
<dd>Position of the specimen in the Container in x direction.[optional]</dd>
<dt><strong><code>storlocy</code></strong> :&ensp;<code>int</code></dt>
<dd>Position of the specimen int the container in y direction.[optional]</dd>
</dl>
<p>concetration
: int
Concentration of the specimen[optional].</p>
<dl>
<dt><strong><code>biohazard</code></strong> :&ensp;<code>string</code></dt>
<dd>Biohazards of that specimen.[optional]</dd>
<dt><strong><code>userid</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the user who creates the specimen. If not specified the API user is taken.</dd>
<dt><strong><code>comments</code></strong> :&ensp;<code>string</code></dt>
<dd>Comments regarding to the specimen[optional].</dd>
<dt><strong><code>collproc</code></strong> :&ensp;<code>string</code></dt>
<dd>The procedure of the collection[otpional].</dd>
<dt><strong><code>conttype</code></strong> :&ensp;<code>string</code></dt>
<dd>Type of the storage conatiner.</dd>
<dt><strong><code>extension</code></strong> :&ensp;<code>JSON-String</code></dt>
<dd>JSON-formated-string containing the dict of specimnen extensions created during call to the corresponding util class</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>JSON-formated-string with the complete specimen to be created</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_specimen_json(self, label=None, specimenclass=None, specimentype=None, pathology=None, anatomic=None,
                        laterality=None, initqty=None, avaqty=None, visitid=None, userid=None, colltime=None,
                        rectime=None, recqlt=None, lineage=&#39;New&#39;, status=&#39;Collected&#39;, storloc=None, concentration=None,
                        biohazard=None, comments=None,  collproc=None, conttype=None, extension =None):


    &#34;&#34;&#34;Create a API Json String for a Specimen
    Create the JSON String neccesary for creating a specimen
    
    Notes
    -----
    Mandatory paramters are passed as positional args within the calling util class
    Parameters
    ----------
    label : string
        UUID of specimen generated automatically if not set to manual in corresponding collection protocol
    
    specimenclass : string
        Class of the specimen.
    
    specimentype : string
        Type of the specimen, belongs to the class.
    
    pathology : string
        Pathologystatus of the Specimen.
    anatomic : string
        The anatomic site of the specimen.
    
    laterality : string
        The laterality of the specimen.
    
    initqty : int
        The initial quantity of a specimen.
    
    avaqty : int
        The available quantity of a specimen.
    
    visitid : int
        The unique identifier of the visit.
    recqlt : string
        The received quality.
        
    colltime : string
        Date and Time of the collection event, the format is in the OpenSpecimen&#39;s System configuration.[optional]
        
    rectime : string
        Date and Time of the received event, the format is in the OpenSpecimen&#39;s System configuration.[optional]
        
    lineage : string
        Lineage of the specimen, default value is New.
        
    status : string
        Status of the Specimen, default is &#39;Collected&#39;.
    
    stor_name : string
        Name of the container. [optional]
    
    storlocx : int
        Position of the specimen in the Container in x direction.[optional]
    storlocy : int
        Position of the specimen int the container in y direction.[optional]
        
    concetration  : int
        Concentration of the specimen[optional].
    
    biohazard : string
        Biohazards of that specimen.[optional]
    
    userid : int
        ID of the user who creates the specimen. If not specified the API user is taken.
        
    comments : string
        Comments regarding to the specimen[optional].
    
    collproc : string
        The procedure of the collection[otpional].
    conttype : string
        Type of the storage conatiner.
        
    extension : JSON-String
        JSON-formated-string containing the dict of specimnen extensions created during call to the corresponding util class 
    
    Returns
    -------
    dict
        JSON-formated-string with the complete specimen to be created
    &#34;&#34;&#34;

    data = {
        &#34;label&#34;: label,
        &#34;specimenClass&#34;: specimenclass,
        &#34;type&#34;: specimentype,
        &#34;pathology&#34;: pathology,
        &#34;anatomicSite&#34;: anatomic,
        &#34;laterality&#34;: laterality,
        &#34;initialQty&#34;: initqty,
        &#34;availableQty&#34;: avaqty,
        &#34;visitId&#34;: visitid,
        &#34;status&#34;: status,
        &#34;storageLocation&#34;: storloc,
        &#34;concetration&#34;: concentration,
        &#34;biohazard&#34;: biohazard,
        &#34;comments&#34;: comments,
        &#34;collectionEvent&#34;: {
            &#34;user&#34;: {&#34;id&#34;: userid},
                &#34;time&#34;: colltime,
                &#34;container&#34;: conttype,
                &#34;procedure&#34;: collproc
                 },
        &#34;receivedEvent&#34;:{
            &#34;user&#34;:{&#34;id&#34;: userid},
            &#34;time&#34;: rectime,
            &#34;receivedQuality&#34;: recqlt
        },
        &#34;extensionDetail&#34;: extension
        }
    
    data = {k: v for k, v in data.items() if v is not None}

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_user_json"><code class="name flex">
<span>def <span class="ident">create_user_json</span></span>(<span>self, first=None, last=None, email=None, phone=None, login=None, institute=None, type_=None, address=None, domain=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create User</p>
<p>Create the payload for creating a user in OpenSpecimen.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>first</code></strong> :&ensp;<code>string</code></dt>
<dd>First name of the user.</dd>
<dt><strong><code>last</code></strong> :&ensp;<code>string</code></dt>
<dd>Last name of the user.</dd>
<dt><strong><code>email</code></strong> :&ensp;<code>string</code></dt>
<dd>Email-address of the user.</dd>
<dt><strong><code>phone</code></strong> :&ensp;<code>string</code></dt>
<dd>Phone number of the user.</dd>
<dt><strong><code>login</code></strong> :&ensp;<code>string</code></dt>
<dd>Login name of the user.</dd>
<dt><strong><code>institute</code></strong> :&ensp;<code>string</code></dt>
<dd>Institute to which the user belongs.</dd>
<dt><strong><code>type_</code></strong> :&ensp;<code>string</code></dt>
<dd>Type of the user.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>string</code></dt>
<dd>Address of the user.</dd>
<dt><strong><code>domain</code></strong> :&ensp;<code>string</code></dt>
<dd>Domain where the user belongs to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>JSON formatted string to create an user such that Openspecimen can read it</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_user_json(self, first = None, last = None, email = None, phone = None, login = None, institute = None,
                    type_ = None, address = None, domain = None):
    
    &#34;&#34;&#34;Create User

    Create the payload for creating a user in OpenSpecimen.

    Parameters
    ----------
    first : string
        First name of the user.
    last : string
        Last name of the user.
    email : string
        Email-address of the user.
    phone : string
        Phone number of the user.
    login : string
        Login name of the user.
    institute : string
        Institute to which the user belongs.
    type_ : string
        Type of the user.
    address : string
        Address of the user.
    domain : string
        Domain where the user belongs to.

    Returns
    -------
    string
        JSON formatted string to create an user such that Openspecimen can read it
    &#34;&#34;&#34;

    data = {
        &#34;firstName&#34; : first,
        &#34;lastName&#34; : last,
        &#34;emailAddress&#34; : email,
        &#34;phoneNumber&#34; : phone,
        &#34;domainName&#34; : domain,
        &#34;loginName&#34; : login,
        &#34;instituteName&#34; : institute,
        &#34;type&#34; : type_,
        &#34;address&#34; : address
    }

    data = {k: v for k, v in data.items() if v is not None}

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.execute_aql"><code class="name flex">
<span>def <span class="ident">execute_aql</span></span>(<span>self, cpid, aql, rowmode='OFF', columnexpr='true', isodate='true')</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON formated string to execute a specified query passed to the method</p>
<p>Parameters
cp_id: string
Collection protocoll id of export target
aql: string
query command in the OpenSpecimen Syntax (see OpenSpecimen API)
rowmode: string
Specifies whether multi-valued attributes result in a single row or one row per value.
Default value is OFF. Other permitted values are SHALLOW and DEEP.
Try out to see what fits best for your use case.
columnexpr: string
Specifies whether the column labels or AQL expression needs to be included in the query response.
By default, user friendly column labels are included in query response.
<br>
isodate: string
Specifies how the date column values needs to be serialised in the query response.
If true, then date/time values are serialised using ISO format: yyyy-MM-dd'T'HH:mm:ss.
Otherwise, date/time values are serialised using the format specified in OS locale settings</p>
<hr>
<p>Returns
JSON-formated-string
Json data needed for executing a system query</p>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_aql(self, cpid, aql, rowmode=&#39;OFF&#39;, columnexpr=&#39;true&#39;, isodate=&#39;true&#39;):
    
    &#34;&#34;&#34;Create JSON formated string to execute a specified query passed to the method

    Parameters
    cp_id: string 
        Collection protocoll id of export target
    aql: string
        query command in the OpenSpecimen Syntax (see OpenSpecimen API) 
    rowmode: string
       Specifies whether multi-valued attributes result in a single row or one row per value. 
       Default value is OFF. Other permitted values are SHALLOW and DEEP. 
       Try out to see what fits best for your use case. 
    columnexpr: string 
        Specifies whether the column labels or AQL expression needs to be included in the query response. 
        By default, user friendly column labels are included in query response.     
    isodate: string
        Specifies how the date column values needs to be serialised in the query response. 
        If true, then date/time values are serialised using ISO format: yyyy-MM-dd&#39;T&#39;HH:mm:ss. 
        Otherwise, date/time values are serialised using the format specified in OS locale settings
    ----------
    Returns
    JSON-formated-string 
        Json data needed for executing a system query
    -------
    &#34;&#34;&#34;
    params = {
        &#34;cpId&#34; : cpid,
        &#34;aql&#34; : aql,
        &#34;wideRowMode&#34; : rowmode,
        &#34;outputColumnExprs&#34; : columnexpr,
        &#34;outputIsoDateTime&#34; : isodate
    }
    
    params = {k: v for k, v in params.items() if v is not None}
    return json.dumps(params)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.execute_query"><code class="name flex">
<span>def <span class="ident">execute_query</span></span>(<span>self, start, results, drivingform='Participant', rowmode='OFF')</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON formated string neccesary for execution of a saved query
Parameters
start: string
Used for paginating the results. If start=5, the output result will start from row number 5.
resutls: string
Used for paginating the results. If results=10, the output result will be maximum 10 rows
drivingform: string
Driving form determines the search perspective. When left empty, it defaults to Participant.
(For example when drivingForm is Participant, the root table is 'catissue_coll_prot_reg'
which is then used to join with the other tables.
Similarly when drivingForm is Specimen, the root table will be catissue_specimen,
which will be joined with the other tables.) rowmode: string</p>
<hr>
<p>Returns
JSON-formated-string
Json data needed for executing a query saved within an Openspecimen appliance</p>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_query(self, start, results, drivingform=&#34;Participant&#34;, rowmode=&#34;OFF&#34;):
    
    &#34;&#34;&#34;Create JSON formated string neccesary for execution of a saved query
    Parameters
    start: string 
        Used for paginating the results. If start=5, the output result will start from row number 5.
    resutls: string
        Used for paginating the results. If results=10, the output result will be maximum 10 rows
    drivingform: string
        Driving form determines the search perspective. When left empty, it defaults to Participant.
        (For example when drivingForm is Participant, the root table is &#39;catissue_coll_prot_reg&#39; 
        which is then used to join with the other tables.
        Similarly when drivingForm is Specimen, the root table will be catissue_specimen, 
        which will be joined with the other tables.) rowmode: string
    ----------
    Returns
    JSON-formated-string 
        Json data needed for executing a query saved within an Openspecimen appliance
    -------
    &#34;&#34;&#34;

    params= {
        &#34;drivingForm&#34;: drivingform,
        &#34;wideRowMode&#34;: rowmode,
        &#34;startAt&#34;: start,
        &#34;maxResults&#34;:results
    }
    params = {k: v for k, v in params.items() if v is not None}
    return json.dumps(params)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.get_participants"><code class="name flex">
<span>def <span class="ident">get_participants</span></span>(<span>self, lastname=None, uid=None, birthdate=None, pmi=None, empi=None, reqreginfo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON-formatted string to neccesary to retrieve storage location via API </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lastname</code></strong> :&ensp;<code>string</code></dt>
<dd>Substring of the Lastname of a Paritcipant.</dd>
<dt><strong><code>uid</code></strong> :&ensp;<code>string</code></dt>
<dd>Country specific unique social security number.</dd>
<dt><strong><code>birthdate</code></strong> :&ensp;<code>string</code></dt>
<dd>The date of registration in the format, which is defined in the System settings.</dd>
<dt><strong><code>pmi</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict with details of the Medical records number mrn and the assigned site with key siteName.</dd>
<dt><strong><code>empi</code></strong> :&ensp;<code>string</code></dt>
<dd>Enterprise wide unique ID assigned to the participant.</dd>
<dt><strong><code>reqreginfo</code></strong> :&ensp;<code>string</code></dt>
<dd>OpenSpecimen's boolean (true/false). If true it returns details of the participant</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-formated string</code></dt>
<dd>JSON-formated string neccesary for creating an institute</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_participants(self, lastname = None, uid = None, birthdate = None, pmi = None, empi = None, reqreginfo = None):

    &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

    Parameters
    ---------
    lastname : string
        Substring of the Lastname of a Paritcipant.
    
    uid : string
        Country specific unique social security number.

    birthdate : string
        The date of registration in the format, which is defined in the System settings.
    
    pmi : dict
        Dict with details of the Medical records number mrn and the assigned site with key siteName.

    empi : string
        Enterprise wide unique ID assigned to the participant.

    reqreginfo : string
        OpenSpecimen&#39;s boolean (true/false). If true it returns details of the participant
    
    Returns
    -------
    JSON-formated string
        JSON-formated string neccesary for creating an institute
    &#34;&#34;&#34;

    
    data ={
        &#34;lastName&#34; : lastname,
        &#34;birthDate&#34; : birthdate,
        &#34;uid&#34; : uid,
        &#34;empi&#34; : empi,
        &#34;reqRegInfo&#34; : reqreginfo
    }
    if pmi==None:
        data[&#39;pmi&#39;]=None
    else:
        data[&#34;pmi&#34;]={
            &#34;mrn&#34; : str(pmi[0]),
            &#34;siteName&#34; : pmi[1]
        }

    data = {k: v for k, v in data.items() if v is not None}
    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.get_registrations"><code class="name flex">
<span>def <span class="ident">get_registrations</span></span>(<span>self, cpid=None, registrationdate=None, ppid=None, name=None, birthdate=None, uid=None, specimen=None, includestats=None, startat=None, maxresults=None, exactmatch=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON formated string neccesary for creating a bulk import operation to be handled by OpenSpecimen</p>
<p>Parameters
cpid : string
Collection protol id of the participants to be queried
registrationdate: string
Date formatted string to query participants registered especially on this date
ppid: string
OpenSpecimen internal unique id or part of a unique id to be matched (exact matching is defind in exact match)
name: string
Name of the participant to be matched
birthdate: string
Date formatted string containing the birthdate of a particiapnt to be queried
uid: string
Social Security number
or different national identifier
specimen: string
Participants whose specimen labels or barcodes contain this parameter value as a substring will be matched
includestats: string
Include additional statitics within the response (visits specimens etc.)
startat: string
startat and maxResults are useful in implementing pagination of participants list. When not specified,
startAt defaults to 0. When startAt = n, the first element of the response is (n + 1)th participant satisfying the query criteria.
maxresults: string
This parameter specifies how many participant records should be included in the API response.
exactmatch: string
Specifies whether the PPID should be exact match or sub-string match. Boolean true means exact match. Otherwise it is substring match.</p>
<hr>
<p>Returns
JSON-formated-string
trg_cp: string
CP id of target of merge action
Json data needed for creating an CSV file import job for the given entity</p>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_registrations(self, cpid=None, registrationdate=None, ppid=None, name=None, birthdate=None, uid=None, specimen=None,
                                includestats=None, startat=None,maxresults=None, exactmatch=None):

    &#34;&#34;&#34;Create JSON formated string neccesary for creating a bulk import operation to be handled by OpenSpecimen

    Parameters
    cpid : string
        Collection protol id of the participants to be queried
    registrationdate: string
        Date formatted string to query participants registered especially on this date
    ppid: string
        OpenSpecimen internal unique id or part of a unique id to be matched (exact matching is defind in exact match)
    name: string
        Name of the participant to be matched
    birthdate: string
        Date formatted string containing the birthdate of a particiapnt to be queried
    uid: string
        Social Security number  or different national identifier
    specimen: string
        Participants whose specimen labels or barcodes contain this parameter value as a substring will be matched
    includestats: string
        Include additional statitics within the response (visits specimens etc.)
    startat: string
        startat and maxResults are useful in implementing pagination of participants list. When not specified, 
        startAt defaults to 0. When startAt = n, the first element of the response is (n + 1)th participant satisfying the query criteria.
    maxresults: string
        This parameter specifies how many participant records should be included in the API response. 
    exactmatch: string
        Specifies whether the PPID should be exact match or sub-string match. Boolean true means exact match. Otherwise it is substring match.
    ----------
    Returns
    JSON-formated-string   trg_cp: string
        CP id of target of merge action
        Json data needed for creating an CSV file import job for the given entity
    -------
    &#34;&#34;&#34;

    params = {
        &#34;cpId&#34;: cpid,
        &#34;registrationDate&#34;: registrationdate,
        &#34;ppid&#34;: ppid,
        &#34;name&#34;: name,
        &#34;dob&#34;: birthdate,
        &#34;uid&#34;: uid,
        &#34;specimen&#34;: specimen,
        &#34;includeStats&#34;: includestats,
        &#34;startAt&#34;: startat,
        &#34;maxResults&#34;: maxresults,
        &#34;exactMatch&#34;: exactmatch
    }

    params = {k: v for k, v in params.items() if v is not None}
    return json.dumps(params)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.merge_cps"><code class="name flex">
<span>def <span class="ident">merge_cps</span></span>(<span>self, src_cp, trg_cp)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON-formatted string to neccesary to retrieve storage location via API </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>src_cp</code></strong> :&ensp;<code>string</code></dt>
<dd>CP id of source collection protocoll for merge</dd>
<dt><strong><code>trg_cp</code></strong> :&ensp;<code>string</code></dt>
<dd>CP id of target of merge action</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-formated string</code></dt>
<dd>JSON-formated string neccesary for merging to CP's via API</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_cps(self, src_cp, trg_cp):
    
    &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

    Parameters
    ----------
    src_cp: string
        CP id of source collection protocoll for merge
    trg_cp: string
        CP id of target of merge action
    Returns
    -------
    JSON-formated string
        JSON-formated string neccesary for merging to CP&#39;s via API
    &#34;&#34;&#34;

    data = {
        &#34;srcCpShortTitle&#34;: src_cp,
        &#34;tgtCpShortTitle&#34;: trg_cp
    }

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.register_to_cp"><code class="name flex">
<span>def <span class="ident">register_to_cp</span></span>(<span>self, cprid, regdate, cpid, ppid)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a Registration to another Protocol</p>
<p>Register an existing Registration to another Collection Protocol.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cprid</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer with the existing Registration Id of the Participant.</dd>
<dt><strong><code>regdate</code></strong> :&ensp;<code>string</code></dt>
<dd>Dete of the Regisrtation to the new protocol.</dd>
<dt><strong><code>cpid</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer with the unique ID of the Collection Protocol.</dd>
<dt><strong><code>ppid</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the Participant protocol ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>Json-formatted string for register a Participant to another Protocol such that OpenSpecimen can read it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_to_cp(self, cprid, regdate, cpid, ppid):

    &#34;&#34;&#34;Register a Registration to another Protocol

    Register an existing Registration to another Collection Protocol.

    Parameters
    ----------
    cprid : int
        Integer with the existing Registration Id of the Participant.
    regdate: string
        Dete of the Regisrtation to the new protocol.
    cpid : int
        Integer with the unique ID of the Collection Protocol.
    ppid : string
        String with the Participant protocol ID.

    Returns
    -------
    string
        Json-formatted string for register a Participant to another Protocol such that OpenSpecimen can read it.
    &#34;&#34;&#34;

    data = {
        &#34;participant&#34;:{&#34;id&#34;:cprid},
        &#34;registrationDate&#34;:regdate,
        &#34;cpId&#34;:cpid,
        &#34;ppid&#34;:ppid
    }

    return json.dumps(data)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.storage_location_json"><code class="name flex">
<span>def <span class="ident">storage_location_json</span></span>(<span>self, id_=None, name=None, xpos=None, ypos=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create JSON-formatted string to neccesary to retrieve storage location via API </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>string</code></dt>
<dd>Identifier of the Storage Container within OpenSpecimen.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>Storage Container name</dd>
<dt><strong><code>xpos</code></strong> :&ensp;<code>string </code></dt>
<dd>x-coordinate within the given storage conatiner grid (if applicable)</dd>
<dt><strong><code>ypos</code></strong> :&ensp;<code>string</code></dt>
<dd>y-coordinate within the given storage container grid (if applicable)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-formated string</code></dt>
<dd>JSON foramted string that is needed to retrieve the storage location of a specimen</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def storage_location_json(self, id_=None, name=None, xpos=None, ypos=None):
    
    &#34;&#34;&#34;Create JSON-formatted string to neccesary to retrieve storage location via API 

    Parameters
    ----------
    id: string
        Identifier of the Storage Container within OpenSpecimen.
    name: string
        Storage Container name
    xpos: string 
        x-coordinate within the given storage conatiner grid (if applicable) 
    ypos: string
        y-coordinate within the given storage container grid (if applicable)     
    Returns
    -------
    JSON-formated string
        JSON foramted string that is needed to retrieve the storage location of a specimen 
    &#34;&#34;&#34;
    
    data = {
        &#34;id&#34;: id_,
        &#34;name&#34;: name,
        &#34;positionX&#34;: xpos,
        &#34;positionY&#34;: ypos
    }

    data = {k: v for k, v in data.items() if v is not None}
    
    return json.dumps(data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="OpenSpecimenAPIconnector.os_core" href="index.html">OpenSpecimenAPIconnector.os_core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory">Json_factory</a></code></h4>
<ul class="">
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.add_visit_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.add_visit_json">add_visit_json</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.assign_user_role_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.assign_user_role_json">assign_user_role_json</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.change_user_pw_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.change_user_pw_json">change_user_pw_json</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_CP_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_CP_json">create_CP_json</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_bulk_import_job" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_bulk_import_job">create_bulk_import_job</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_cp_event_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_cp_event_json">create_cp_event_json</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_csv_export_job" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_csv_export_job">create_csv_export_job</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_extension" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_extension">create_extension</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_institute" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_institute">create_institute</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_participant_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_participant_json">create_participant_json</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_site" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_site">create_site</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_specimen_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_specimen_json">create_specimen_json</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_user_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.create_user_json">create_user_json</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.execute_aql" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.execute_aql">execute_aql</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.execute_query" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.execute_query">execute_query</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.get_participants" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.get_participants">get_participants</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.get_registrations" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.get_registrations">get_registrations</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.merge_cps" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.merge_cps">merge_cps</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.register_to_cp" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.register_to_cp">register_to_cp</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.jsons.Json_factory.storage_location_json" href="#OpenSpecimenAPIconnector.os_core.jsons.Json_factory.storage_location_json">storage_location_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>