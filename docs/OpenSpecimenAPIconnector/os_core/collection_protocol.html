<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>OpenSpecimenAPIconnector.os_core.collection_protocol API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>OpenSpecimenAPIconnector.os_core.collection_protocol</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /bin/python3

import json
from .req_util import OS_request_gen
from .jsons import Json_factory


class collection_protocol():

    &#34;&#34;&#34;Handles the calls Colelction Protocol

    This class handles the API calls for OpenSpecimen Collection Protocol. It can create, delete, 
    search a Protocol with different parameters, get all Collection Protocols in the Sytem, 
    get the template of the Colelction Protocols as JSON dict or  as Pandas dataframe.
    The output is a JSON dict or the Error message as JSON dict, except the Pandas dataframe.
    

    Notes
    -----
    In order to use this and also the other classes, the user has to know OpenSpecimen. In the core classes one can
    just pass the parameters via JSON-formatted string. This means the user has to know the keywords.
    The API calls are documented in https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs and 
    the calls refer to this site. More details can be seen in the documentation.

    Example
    -------

    A code example, where the Collection protocols are handled is in the Jupyter-Notebook::

        $ jupyter notebook main.ipynb
    &#34;&#34;&#34;

    def __init__(self, base_url, auth):

        &#34;&#34;&#34;Constructor of the Class collection_protocol

        Constructor of the class colelction_protocol, can handle the basic API-calls
        of the collection protocol in OpenSpecimen. Connects this class to OpenSpecimen
        specific request handle (os_core.request_util.py).

        Parameters
        ----------
        base_url : string
            URL to openspecimen, has the format: http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/ng
        auth : tuple
            Consits of two strings ( loginname , password)
        &#34;&#34;&#34;

        self.OS_request_gen = OS_request_gen(auth)
        self.base_url = base_url + &#39;/collection-protocols&#39;
        self.jsons = Json_factory()

    def ausgabe(self):

        &#34;&#34;&#34;Testing of the URL and authentification.

        If there are unexpected errors one can easily test if the URL and login data is correctly spelled.
        the function prints the URL and login data, handed over to the class, to the output terminal.
        &#34;&#34;&#34;

        print(self.base_url, self.OS_request_gen.auth)


    def create_collection_protocol(self, params):

        &#34;&#34;&#34;Creates a Collection Protocol

        Creates a Collection protocol in OpenSpecimen. In order to use this function one has to know
        the parameters which OpenSpecimen needs to create a protocol. One can use it via the os_util class
        collection_protocol_util. This allows just the basic definition, if one has Extensions 
        e.g. BBMRI contact, this fields has to be added separatly. 

        Parameters
        ----------
        params : string
            JSON formatted string with parameters: title, shortTitle, code[optional], startDate[optional],
            endDate[optional], principalInvestigator, coordinators[optional], irbId[optonal],
            anticipatedParticipantsCount[optional], activityStatus, visitNameFmt[optional],
            specimenLabel[optional], derivedlabelFormat[optional], ppIdFormat[optional], cpSites,
            manualPpidEnabled[optional], manualVisitNameEnabled[optional], manualSpecLabelEnabled[optional]

        Returns
        -------
        json-dict
            Either details of the created protocol 
        &#34;&#34;&#34;

        url = self.base_url + &#39;/&#39;
        payload = params
        r = self.OS_request_gen.get_request(url)

        return json.loads(r.text)


    def delete_collection_protocol(self, cpid):

        &#34;&#34;&#34;Delete a Collection Protocol with OpenSpeimens unique CollectionProtocolID

        Delete an already existing Collection Protocol. The parameter ::cpid:: is the uniqe ID of the Collection Protocol
        which is generated automatically from OpenSpecimen. To get the ID one can click in the GUI on the Collection Protocol
        Details button and read it from the URL, with format: http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/#/cp-view/{cpid}/overview.
        An other possibility is to search via &#39;search_collection_protocols&#39; for a specific parameter and then extract the ID
        from the JSON-dict which get returned.

        Parameters
        ----------
        cpid: string or int
            The unique ID of the collection protocol which OpenSpecimen creates itselfs as a string or integer. 
            It will get converted to a string.

        Returns
        -------
        JSON-dict
            Details of the Collection Protocol which is deleted or the OpenSpecimen error message as dict.
        &#34;&#34;&#34;

        endpoint = &#39;/&#39; + str(cpid)
        url = self.base_url + endpoint
        r = self.OS_request_gen.delete_request(url)

        return json.loads(r.text)


    def search_collection_protocols(self, search_string):

        &#34;&#34;&#34;Search for  Colelction Protocols with specific values.

        Search for one or more Collection Protocols with the search_string defined. The search string looks like:
        http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/np/collection-protocols?{param_1}={value_1}&amp;...&amp;{param_x}={value_x}
        With the class collection_protocol_util from os_util and function ::search_cps:: the search string is generated
        and this function is called. Not all keys from OpenSpecimen can be easily searched after.

        Parameters
        ----------
        search_string : string
            String with the following format: ?{param_1}={value_1}&amp;...&amp;{param_x}={value_x} . The parameters can be one of the following:
            searchString (OpenSpecimen&#39;s AQL)[optional], title[optional], piId (Principa Investigator)[optional], 
            repositoryName[optional], startAt[optional], maxResults[optional], detailedList[optional]

        Returns
        -------
        JSON-dict
            [Details of the matching Collection Protocols, if no one matches it is an empty list.
        &#34;&#34;&#34;

        endpoint =  str(search_string)
        url = self.base_url+endpoint
        
        r = self.OS_request_gen.get_request(url)

        return json.loads(r.text)


    def get_all_collection_protocols(self):

        &#34;&#34;&#34;Get all Colelction Protocol

        Get all Colletion Protocols within the OpenSpecimen distribution, which is defined in the base_url.


        Returns
        -------
        JSON-dict
            Details of all Collectiion Protols which are in the OpenSpecimenDistribution.
        &#34;&#34;&#34;

        url = self.base_url
        r = self.OS_request_gen.get_request(url)
        return json.loads(r.text)


    def get_collection_protocol(self, cpid):

        &#34;&#34;&#34;Get the Colelction Protocol with the ID ::cpid::

        Get the details of the Collection Protocol with the unique ID ::cpid::.
        This ID is generated automatically from OpenSpecimen when the Protocol is created.

        Parameters
        ----------
        cpid : string or int
            The System&#39;s ID of the Collection Protocol, will be converted to a string.

        Returns
        -------
        JSON-dict
            Details of the Collection Protocol with the specified ID, or the OpenSpecimen error message.
        &#34;&#34;&#34;

        endpoint = &#39;/&#39; + str(cpid)
        url = self.base_url + endpoint
        r = self.OS_request_gen.get_request(url)

        return json.loads(r.text)


    def merge_colelction_protocols(self, params):

        &#34;&#34;&#34;Merge two Collection Protocols

        Merge two Colelction Protocols which are defined in params together. To call this function the short titles of
        the source and target collection protocol has to be known. The parameter ::params:: is a json-formatted string,
        with keys srcCPShortTitle and tgtCpShorttitle. The merged Protocol is the one with short title tgtCpShortTitle,
        with merge logic outer. 

        Note
        ----
        Merging is restricted to Super Admins. The CPs must have the same format for PPI, visits and specimens. Or the target CP 
        has no specific formats. 

        Parameters
        ----------
        params : string
            JSON formatted string with keys srcCpShortTitle and tgtCpShortTitle and the corresponding short titles as values.

        Returns
        -------
        JSON-dict
            JSON dict with the short titles of the source and target Colelction Protocols.           
        &#34;&#34;&#34;

        endpoint = &#39;/merge&#39;
        url = self.base_url + endpoint
        r = self.OS_request_gen.post_request(url, params)

        return json.loads(r.text)


#   Update colelction Protocol
#   Input:  - cpid: ID of the Colelction Protocol which should get updated
#           - params: Paramters which should get updated
#   Output: - eiher details of the CP as json formatted  string
#           - or error message
    def update_collection_protocol(self, cpid, params):

        &#34;&#34;&#34;Updates a existing Collection Protocol with ID ::cpid:: with the Parameters ::params::

        Updates a existing Colelction Protocol with the automatically generated OpsenSpecimen&#39;s system wide
        unique Collection Protocol ID ::cpid::, with the Parameters ::params:: which are passed to the function.
        The ID of the Collection Protocol have to be known and can for example be seen in the GUI by clicking on 
        the Collection Protocol, which has the format http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/cps/{cpid}/... .
        Or via the function search_collection_protocols or get_all_collection_protocols

        Note
        ----
        The optional parameters are those, which are optional for a Collection Protocol. For updating all parameters are optional,
        does which are not passed to the function will stay the same as before.

        Parameter
        ---------
        cpid : strinf or int
            Unique Collection Protocol ID which is generated automatically from the System. It will be converted to a string.
        
        params : string
            JSON-formatted string with the parameters which should get updated. the keys which can get updated are: 
            title, shortTitle, code[optional], startDate[optional], endDate[optional], principalInvestigator, 
            coordinators[optional], irbId[optonal], anticipatedParticipantsCount[optional], activityStatus, visitNameFmt[optional],
            specimenLabel[optional], derivedlabelFormat[optional], ppIdFormat[optional], cpSites,
            manualPpidEnabled[optional], manualVisitNameEnabled[optional], manualSpecLabelEnabled[optional]

        Returns
        -------
        JSON-dict
            JSON-dict with the details of the updated Colelction Protocol or the OpenSpecimen&#39;s error message.
        &#34;&#34;&#34;

        endpoint = &#39;/&#39; + str(cpid)
        url = self.base_url + endpoint
        payload = params
        r = self.OS_request_gen.put_request(url, payload)

        return json.loads(r.text)

    def get_cp_pandas_template(self):
        
        &#34;&#34;&#34;Template for the Collection Protocol

        Template for the Collection Protocol as specified within the system. If for example some extension details
        for the Collection Protocols exists, this function will return also those values. These values are converted into a pandas 
        dataframe, precisely it is the header of a pandas data frame.

        Returns
        -------
        pandas.core.dataframe
            Empty pandas dataframe with OpenSpecimen keys as header inclusive extension details.
        &#34;&#34;&#34;

        site_template_endpoint = &#34;/import-jobs/input-file-template?schema=cp&#34;
        site_template_url = self.base_url + site_template_endpoint
        r = self.OS_request_gen.get_request(site_template_url)
        cp_pandas_template = pd.DataFrame(columns=[r.content.decode()])

        return cp_pandas_template

    def get_cp_def(self, cpid):

        cp_endpoint = &#34;/{}/definition&#34;.format(cpid)
        cp_url = self.base_url + cp_endpoint
        r = self.OS_request_gen.get_request(cp_url)
        cp_def_json = json.loads(r.text)

        return cp_def_json</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol"><code class="flex name class">
<span>class <span class="ident">collection_protocol</span></span>
<span>(</span><span>base_url, auth)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles the calls Colelction Protocol</p>
<p>This class handles the API calls for OpenSpecimen Collection Protocol. It can create, delete,
search a Protocol with different parameters, get all Collection Protocols in the Sytem,
get the template of the Colelction Protocols as JSON dict or
as Pandas dataframe.
The output is a JSON dict or the Error message as JSON dict, except the Pandas dataframe.</p>
<h2 id="notes">Notes</h2>
<p>In order to use this and also the other classes, the user has to know OpenSpecimen. In the core classes one can
just pass the parameters via JSON-formatted string. This means the user has to know the keywords.
The API calls are documented in <a href="https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs">https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs</a> and
the calls refer to this site. More details can be seen in the documentation.</p>
<h2 id="example">Example</h2>
<p>A code example, where the Collection protocols are handled is in the Jupyter-Notebook::</p>
<pre><code>$ jupyter notebook main.ipynb
</code></pre>
<p>Constructor of the Class collection_protocol</p>
<p>Constructor of the class colelction_protocol, can handle the basic API-calls
of the collection protocol in OpenSpecimen. Connects this class to OpenSpecimen
specific request handle (os_core.request_util.py).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>base_url</code></strong> :&ensp;<code>string</code></dt>
<dd>URL to openspecimen, has the format: http(s)://<host>:<port>/openspecimen/rest/ng</dd>
<dt><strong><code>auth</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Consits of two strings ( loginname , password)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class collection_protocol():

    &#34;&#34;&#34;Handles the calls Colelction Protocol

    This class handles the API calls for OpenSpecimen Collection Protocol. It can create, delete, 
    search a Protocol with different parameters, get all Collection Protocols in the Sytem, 
    get the template of the Colelction Protocols as JSON dict or  as Pandas dataframe.
    The output is a JSON dict or the Error message as JSON dict, except the Pandas dataframe.
    

    Notes
    -----
    In order to use this and also the other classes, the user has to know OpenSpecimen. In the core classes one can
    just pass the parameters via JSON-formatted string. This means the user has to know the keywords.
    The API calls are documented in https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs and 
    the calls refer to this site. More details can be seen in the documentation.

    Example
    -------

    A code example, where the Collection protocols are handled is in the Jupyter-Notebook::

        $ jupyter notebook main.ipynb
    &#34;&#34;&#34;

    def __init__(self, base_url, auth):

        &#34;&#34;&#34;Constructor of the Class collection_protocol

        Constructor of the class colelction_protocol, can handle the basic API-calls
        of the collection protocol in OpenSpecimen. Connects this class to OpenSpecimen
        specific request handle (os_core.request_util.py).

        Parameters
        ----------
        base_url : string
            URL to openspecimen, has the format: http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/ng
        auth : tuple
            Consits of two strings ( loginname , password)
        &#34;&#34;&#34;

        self.OS_request_gen = OS_request_gen(auth)
        self.base_url = base_url + &#39;/collection-protocols&#39;
        self.jsons = Json_factory()

    def ausgabe(self):

        &#34;&#34;&#34;Testing of the URL and authentification.

        If there are unexpected errors one can easily test if the URL and login data is correctly spelled.
        the function prints the URL and login data, handed over to the class, to the output terminal.
        &#34;&#34;&#34;

        print(self.base_url, self.OS_request_gen.auth)


    def create_collection_protocol(self, params):

        &#34;&#34;&#34;Creates a Collection Protocol

        Creates a Collection protocol in OpenSpecimen. In order to use this function one has to know
        the parameters which OpenSpecimen needs to create a protocol. One can use it via the os_util class
        collection_protocol_util. This allows just the basic definition, if one has Extensions 
        e.g. BBMRI contact, this fields has to be added separatly. 

        Parameters
        ----------
        params : string
            JSON formatted string with parameters: title, shortTitle, code[optional], startDate[optional],
            endDate[optional], principalInvestigator, coordinators[optional], irbId[optonal],
            anticipatedParticipantsCount[optional], activityStatus, visitNameFmt[optional],
            specimenLabel[optional], derivedlabelFormat[optional], ppIdFormat[optional], cpSites,
            manualPpidEnabled[optional], manualVisitNameEnabled[optional], manualSpecLabelEnabled[optional]

        Returns
        -------
        json-dict
            Either details of the created protocol 
        &#34;&#34;&#34;

        url = self.base_url + &#39;/&#39;
        payload = params
        r = self.OS_request_gen.get_request(url)

        return json.loads(r.text)


    def delete_collection_protocol(self, cpid):

        &#34;&#34;&#34;Delete a Collection Protocol with OpenSpeimens unique CollectionProtocolID

        Delete an already existing Collection Protocol. The parameter ::cpid:: is the uniqe ID of the Collection Protocol
        which is generated automatically from OpenSpecimen. To get the ID one can click in the GUI on the Collection Protocol
        Details button and read it from the URL, with format: http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/#/cp-view/{cpid}/overview.
        An other possibility is to search via &#39;search_collection_protocols&#39; for a specific parameter and then extract the ID
        from the JSON-dict which get returned.

        Parameters
        ----------
        cpid: string or int
            The unique ID of the collection protocol which OpenSpecimen creates itselfs as a string or integer. 
            It will get converted to a string.

        Returns
        -------
        JSON-dict
            Details of the Collection Protocol which is deleted or the OpenSpecimen error message as dict.
        &#34;&#34;&#34;

        endpoint = &#39;/&#39; + str(cpid)
        url = self.base_url + endpoint
        r = self.OS_request_gen.delete_request(url)

        return json.loads(r.text)


    def search_collection_protocols(self, search_string):

        &#34;&#34;&#34;Search for  Colelction Protocols with specific values.

        Search for one or more Collection Protocols with the search_string defined. The search string looks like:
        http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/np/collection-protocols?{param_1}={value_1}&amp;...&amp;{param_x}={value_x}
        With the class collection_protocol_util from os_util and function ::search_cps:: the search string is generated
        and this function is called. Not all keys from OpenSpecimen can be easily searched after.

        Parameters
        ----------
        search_string : string
            String with the following format: ?{param_1}={value_1}&amp;...&amp;{param_x}={value_x} . The parameters can be one of the following:
            searchString (OpenSpecimen&#39;s AQL)[optional], title[optional], piId (Principa Investigator)[optional], 
            repositoryName[optional], startAt[optional], maxResults[optional], detailedList[optional]

        Returns
        -------
        JSON-dict
            [Details of the matching Collection Protocols, if no one matches it is an empty list.
        &#34;&#34;&#34;

        endpoint =  str(search_string)
        url = self.base_url+endpoint
        
        r = self.OS_request_gen.get_request(url)

        return json.loads(r.text)


    def get_all_collection_protocols(self):

        &#34;&#34;&#34;Get all Colelction Protocol

        Get all Colletion Protocols within the OpenSpecimen distribution, which is defined in the base_url.


        Returns
        -------
        JSON-dict
            Details of all Collectiion Protols which are in the OpenSpecimenDistribution.
        &#34;&#34;&#34;

        url = self.base_url
        r = self.OS_request_gen.get_request(url)
        return json.loads(r.text)


    def get_collection_protocol(self, cpid):

        &#34;&#34;&#34;Get the Colelction Protocol with the ID ::cpid::

        Get the details of the Collection Protocol with the unique ID ::cpid::.
        This ID is generated automatically from OpenSpecimen when the Protocol is created.

        Parameters
        ----------
        cpid : string or int
            The System&#39;s ID of the Collection Protocol, will be converted to a string.

        Returns
        -------
        JSON-dict
            Details of the Collection Protocol with the specified ID, or the OpenSpecimen error message.
        &#34;&#34;&#34;

        endpoint = &#39;/&#39; + str(cpid)
        url = self.base_url + endpoint
        r = self.OS_request_gen.get_request(url)

        return json.loads(r.text)


    def merge_colelction_protocols(self, params):

        &#34;&#34;&#34;Merge two Collection Protocols

        Merge two Colelction Protocols which are defined in params together. To call this function the short titles of
        the source and target collection protocol has to be known. The parameter ::params:: is a json-formatted string,
        with keys srcCPShortTitle and tgtCpShorttitle. The merged Protocol is the one with short title tgtCpShortTitle,
        with merge logic outer. 

        Note
        ----
        Merging is restricted to Super Admins. The CPs must have the same format for PPI, visits and specimens. Or the target CP 
        has no specific formats. 

        Parameters
        ----------
        params : string
            JSON formatted string with keys srcCpShortTitle and tgtCpShortTitle and the corresponding short titles as values.

        Returns
        -------
        JSON-dict
            JSON dict with the short titles of the source and target Colelction Protocols.           
        &#34;&#34;&#34;

        endpoint = &#39;/merge&#39;
        url = self.base_url + endpoint
        r = self.OS_request_gen.post_request(url, params)

        return json.loads(r.text)


#   Update colelction Protocol
#   Input:  - cpid: ID of the Colelction Protocol which should get updated
#           - params: Paramters which should get updated
#   Output: - eiher details of the CP as json formatted  string
#           - or error message
    def update_collection_protocol(self, cpid, params):

        &#34;&#34;&#34;Updates a existing Collection Protocol with ID ::cpid:: with the Parameters ::params::

        Updates a existing Colelction Protocol with the automatically generated OpsenSpecimen&#39;s system wide
        unique Collection Protocol ID ::cpid::, with the Parameters ::params:: which are passed to the function.
        The ID of the Collection Protocol have to be known and can for example be seen in the GUI by clicking on 
        the Collection Protocol, which has the format http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/cps/{cpid}/... .
        Or via the function search_collection_protocols or get_all_collection_protocols

        Note
        ----
        The optional parameters are those, which are optional for a Collection Protocol. For updating all parameters are optional,
        does which are not passed to the function will stay the same as before.

        Parameter
        ---------
        cpid : strinf or int
            Unique Collection Protocol ID which is generated automatically from the System. It will be converted to a string.
        
        params : string
            JSON-formatted string with the parameters which should get updated. the keys which can get updated are: 
            title, shortTitle, code[optional], startDate[optional], endDate[optional], principalInvestigator, 
            coordinators[optional], irbId[optonal], anticipatedParticipantsCount[optional], activityStatus, visitNameFmt[optional],
            specimenLabel[optional], derivedlabelFormat[optional], ppIdFormat[optional], cpSites,
            manualPpidEnabled[optional], manualVisitNameEnabled[optional], manualSpecLabelEnabled[optional]

        Returns
        -------
        JSON-dict
            JSON-dict with the details of the updated Colelction Protocol or the OpenSpecimen&#39;s error message.
        &#34;&#34;&#34;

        endpoint = &#39;/&#39; + str(cpid)
        url = self.base_url + endpoint
        payload = params
        r = self.OS_request_gen.put_request(url, payload)

        return json.loads(r.text)

    def get_cp_pandas_template(self):
        
        &#34;&#34;&#34;Template for the Collection Protocol

        Template for the Collection Protocol as specified within the system. If for example some extension details
        for the Collection Protocols exists, this function will return also those values. These values are converted into a pandas 
        dataframe, precisely it is the header of a pandas data frame.

        Returns
        -------
        pandas.core.dataframe
            Empty pandas dataframe with OpenSpecimen keys as header inclusive extension details.
        &#34;&#34;&#34;

        site_template_endpoint = &#34;/import-jobs/input-file-template?schema=cp&#34;
        site_template_url = self.base_url + site_template_endpoint
        r = self.OS_request_gen.get_request(site_template_url)
        cp_pandas_template = pd.DataFrame(columns=[r.content.decode()])

        return cp_pandas_template

    def get_cp_def(self, cpid):

        cp_endpoint = &#34;/{}/definition&#34;.format(cpid)
        cp_url = self.base_url + cp_endpoint
        r = self.OS_request_gen.get_request(cp_url)
        cp_def_json = json.loads(r.text)

        return cp_def_json</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.ausgabe"><code class="name flex">
<span>def <span class="ident">ausgabe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Testing of the URL and authentification.</p>
<p>If there are unexpected errors one can easily test if the URL and login data is correctly spelled.
the function prints the URL and login data, handed over to the class, to the output terminal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ausgabe(self):

    &#34;&#34;&#34;Testing of the URL and authentification.

    If there are unexpected errors one can easily test if the URL and login data is correctly spelled.
    the function prints the URL and login data, handed over to the class, to the output terminal.
    &#34;&#34;&#34;

    print(self.base_url, self.OS_request_gen.auth)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.create_collection_protocol"><code class="name flex">
<span>def <span class="ident">create_collection_protocol</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Collection Protocol</p>
<p>Creates a Collection protocol in OpenSpecimen. In order to use this function one has to know
the parameters which OpenSpecimen needs to create a protocol. One can use it via the os_util class
collection_protocol_util. This allows just the basic definition, if one has Extensions
e.g. BBMRI contact, this fields has to be added separatly. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>string</code></dt>
<dd>JSON formatted string with parameters: title, shortTitle, code[optional], startDate[optional],
endDate[optional], principalInvestigator, coordinators[optional], irbId[optonal],
anticipatedParticipantsCount[optional], activityStatus, visitNameFmt[optional],
specimenLabel[optional], derivedlabelFormat[optional], ppIdFormat[optional], cpSites,
manualPpidEnabled[optional], manualVisitNameEnabled[optional], manualSpecLabelEnabled[optional]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>json-dict</code></dt>
<dd>Either details of the created protocol</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_collection_protocol(self, params):

    &#34;&#34;&#34;Creates a Collection Protocol

    Creates a Collection protocol in OpenSpecimen. In order to use this function one has to know
    the parameters which OpenSpecimen needs to create a protocol. One can use it via the os_util class
    collection_protocol_util. This allows just the basic definition, if one has Extensions 
    e.g. BBMRI contact, this fields has to be added separatly. 

    Parameters
    ----------
    params : string
        JSON formatted string with parameters: title, shortTitle, code[optional], startDate[optional],
        endDate[optional], principalInvestigator, coordinators[optional], irbId[optonal],
        anticipatedParticipantsCount[optional], activityStatus, visitNameFmt[optional],
        specimenLabel[optional], derivedlabelFormat[optional], ppIdFormat[optional], cpSites,
        manualPpidEnabled[optional], manualVisitNameEnabled[optional], manualSpecLabelEnabled[optional]

    Returns
    -------
    json-dict
        Either details of the created protocol 
    &#34;&#34;&#34;

    url = self.base_url + &#39;/&#39;
    payload = params
    r = self.OS_request_gen.get_request(url)

    return json.loads(r.text)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.delete_collection_protocol"><code class="name flex">
<span>def <span class="ident">delete_collection_protocol</span></span>(<span>self, cpid)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a Collection Protocol with OpenSpeimens unique CollectionProtocolID</p>
<p>Delete an already existing Collection Protocol. The parameter ::cpid:: is the uniqe ID of the Collection Protocol
which is generated automatically from OpenSpecimen. To get the ID one can click in the GUI on the Collection Protocol
Details button and read it from the URL, with format: http(s)://<host>:<port>/openspecimen/#/cp-view/{cpid}/overview.
An other possibility is to search via 'search_collection_protocols' for a specific parameter and then extract the ID
from the JSON-dict which get returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cpid</code></strong> :&ensp;<code>string</code> or <code>int</code></dt>
<dd>The unique ID of the collection protocol which OpenSpecimen creates itselfs as a string or integer.
It will get converted to a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>Details of the Collection Protocol which is deleted or the OpenSpecimen error message as dict.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_collection_protocol(self, cpid):

    &#34;&#34;&#34;Delete a Collection Protocol with OpenSpeimens unique CollectionProtocolID

    Delete an already existing Collection Protocol. The parameter ::cpid:: is the uniqe ID of the Collection Protocol
    which is generated automatically from OpenSpecimen. To get the ID one can click in the GUI on the Collection Protocol
    Details button and read it from the URL, with format: http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/#/cp-view/{cpid}/overview.
    An other possibility is to search via &#39;search_collection_protocols&#39; for a specific parameter and then extract the ID
    from the JSON-dict which get returned.

    Parameters
    ----------
    cpid: string or int
        The unique ID of the collection protocol which OpenSpecimen creates itselfs as a string or integer. 
        It will get converted to a string.

    Returns
    -------
    JSON-dict
        Details of the Collection Protocol which is deleted or the OpenSpecimen error message as dict.
    &#34;&#34;&#34;

    endpoint = &#39;/&#39; + str(cpid)
    url = self.base_url + endpoint
    r = self.OS_request_gen.delete_request(url)

    return json.loads(r.text)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_all_collection_protocols"><code class="name flex">
<span>def <span class="ident">get_all_collection_protocols</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all Colelction Protocol</p>
<p>Get all Colletion Protocols within the OpenSpecimen distribution, which is defined in the base_url.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>Details of all Collectiion Protols which are in the OpenSpecimenDistribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_collection_protocols(self):

    &#34;&#34;&#34;Get all Colelction Protocol

    Get all Colletion Protocols within the OpenSpecimen distribution, which is defined in the base_url.


    Returns
    -------
    JSON-dict
        Details of all Collectiion Protols which are in the OpenSpecimenDistribution.
    &#34;&#34;&#34;

    url = self.base_url
    r = self.OS_request_gen.get_request(url)
    return json.loads(r.text)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_collection_protocol"><code class="name flex">
<span>def <span class="ident">get_collection_protocol</span></span>(<span>self, cpid)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Colelction Protocol with the ID ::cpid::</p>
<p>Get the details of the Collection Protocol with the unique ID ::cpid::.
This ID is generated automatically from OpenSpecimen when the Protocol is created.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cpid</code></strong> :&ensp;<code>string</code> or <code>int</code></dt>
<dd>The System's ID of the Collection Protocol, will be converted to a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>Details of the Collection Protocol with the specified ID, or the OpenSpecimen error message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_collection_protocol(self, cpid):

    &#34;&#34;&#34;Get the Colelction Protocol with the ID ::cpid::

    Get the details of the Collection Protocol with the unique ID ::cpid::.
    This ID is generated automatically from OpenSpecimen when the Protocol is created.

    Parameters
    ----------
    cpid : string or int
        The System&#39;s ID of the Collection Protocol, will be converted to a string.

    Returns
    -------
    JSON-dict
        Details of the Collection Protocol with the specified ID, or the OpenSpecimen error message.
    &#34;&#34;&#34;

    endpoint = &#39;/&#39; + str(cpid)
    url = self.base_url + endpoint
    r = self.OS_request_gen.get_request(url)

    return json.loads(r.text)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_cp_def"><code class="name flex">
<span>def <span class="ident">get_cp_def</span></span>(<span>self, cpid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cp_def(self, cpid):

    cp_endpoint = &#34;/{}/definition&#34;.format(cpid)
    cp_url = self.base_url + cp_endpoint
    r = self.OS_request_gen.get_request(cp_url)
    cp_def_json = json.loads(r.text)

    return cp_def_json</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_cp_pandas_template"><code class="name flex">
<span>def <span class="ident">get_cp_pandas_template</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Template for the Collection Protocol</p>
<p>Template for the Collection Protocol as specified within the system. If for example some extension details
for the Collection Protocols exists, this function will return also those values. These values are converted into a pandas
dataframe, precisely it is the header of a pandas data frame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.core.dataframe</code></dt>
<dd>Empty pandas dataframe with OpenSpecimen keys as header inclusive extension details.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cp_pandas_template(self):
    
    &#34;&#34;&#34;Template for the Collection Protocol

    Template for the Collection Protocol as specified within the system. If for example some extension details
    for the Collection Protocols exists, this function will return also those values. These values are converted into a pandas 
    dataframe, precisely it is the header of a pandas data frame.

    Returns
    -------
    pandas.core.dataframe
        Empty pandas dataframe with OpenSpecimen keys as header inclusive extension details.
    &#34;&#34;&#34;

    site_template_endpoint = &#34;/import-jobs/input-file-template?schema=cp&#34;
    site_template_url = self.base_url + site_template_endpoint
    r = self.OS_request_gen.get_request(site_template_url)
    cp_pandas_template = pd.DataFrame(columns=[r.content.decode()])

    return cp_pandas_template</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.merge_colelction_protocols"><code class="name flex">
<span>def <span class="ident">merge_colelction_protocols</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge two Collection Protocols</p>
<p>Merge two Colelction Protocols which are defined in params together. To call this function the short titles of
the source and target collection protocol has to be known. The parameter ::params:: is a json-formatted string,
with keys srcCPShortTitle and tgtCpShorttitle. The merged Protocol is the one with short title tgtCpShortTitle,
with merge logic outer. </p>
<h2 id="note">Note</h2>
<p>Merging is restricted to Super Admins. The CPs must have the same format for PPI, visits and specimens. Or the target CP
has no specific formats. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>string</code></dt>
<dd>JSON formatted string with keys srcCpShortTitle and tgtCpShortTitle and the corresponding short titles as values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>JSON dict with the short titles of the source and target Colelction Protocols.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_colelction_protocols(self, params):

    &#34;&#34;&#34;Merge two Collection Protocols

    Merge two Colelction Protocols which are defined in params together. To call this function the short titles of
    the source and target collection protocol has to be known. The parameter ::params:: is a json-formatted string,
    with keys srcCPShortTitle and tgtCpShorttitle. The merged Protocol is the one with short title tgtCpShortTitle,
    with merge logic outer. 

    Note
    ----
    Merging is restricted to Super Admins. The CPs must have the same format for PPI, visits and specimens. Or the target CP 
    has no specific formats. 

    Parameters
    ----------
    params : string
        JSON formatted string with keys srcCpShortTitle and tgtCpShortTitle and the corresponding short titles as values.

    Returns
    -------
    JSON-dict
        JSON dict with the short titles of the source and target Colelction Protocols.           
    &#34;&#34;&#34;

    endpoint = &#39;/merge&#39;
    url = self.base_url + endpoint
    r = self.OS_request_gen.post_request(url, params)

    return json.loads(r.text)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.search_collection_protocols"><code class="name flex">
<span>def <span class="ident">search_collection_protocols</span></span>(<span>self, search_string)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for
Colelction Protocols with specific values.</p>
<p>Search for one or more Collection Protocols with the search_string defined. The search string looks like:
http(s)://<host>:<port>/openspecimen/rest/np/collection-protocols?{param_1}={value_1}&amp;&hellip;&amp;{param_x}={value_x}
With the class collection_protocol_util from os_util and function ::search_cps:: the search string is generated
and this function is called. Not all keys from OpenSpecimen can be easily searched after.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>search_string</code></strong> :&ensp;<code>string</code></dt>
<dd>String with the following format: ?{param_1}={value_1}&amp;&hellip;&amp;{param_x}={value_x} . The parameters can be one of the following:
searchString (OpenSpecimen's AQL)[optional], title[optional], piId (Principa Investigator)[optional],
repositoryName[optional], startAt[optional], maxResults[optional], detailedList[optional]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>[Details of the matching Collection Protocols, if no one matches it is an empty list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_collection_protocols(self, search_string):

    &#34;&#34;&#34;Search for  Colelction Protocols with specific values.

    Search for one or more Collection Protocols with the search_string defined. The search string looks like:
    http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/rest/np/collection-protocols?{param_1}={value_1}&amp;...&amp;{param_x}={value_x}
    With the class collection_protocol_util from os_util and function ::search_cps:: the search string is generated
    and this function is called. Not all keys from OpenSpecimen can be easily searched after.

    Parameters
    ----------
    search_string : string
        String with the following format: ?{param_1}={value_1}&amp;...&amp;{param_x}={value_x} . The parameters can be one of the following:
        searchString (OpenSpecimen&#39;s AQL)[optional], title[optional], piId (Principa Investigator)[optional], 
        repositoryName[optional], startAt[optional], maxResults[optional], detailedList[optional]

    Returns
    -------
    JSON-dict
        [Details of the matching Collection Protocols, if no one matches it is an empty list.
    &#34;&#34;&#34;

    endpoint =  str(search_string)
    url = self.base_url+endpoint
    
    r = self.OS_request_gen.get_request(url)

    return json.loads(r.text)</code></pre>
</details>
</dd>
<dt id="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.update_collection_protocol"><code class="name flex">
<span>def <span class="ident">update_collection_protocol</span></span>(<span>self, cpid, params)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates a existing Collection Protocol with ID ::cpid:: with the Parameters ::params::</p>
<p>Updates a existing Colelction Protocol with the automatically generated OpsenSpecimen's system wide
unique Collection Protocol ID ::cpid::, with the Parameters ::params:: which are passed to the function.
The ID of the Collection Protocol have to be known and can for example be seen in the GUI by clicking on
the Collection Protocol, which has the format http(s)://<host>:<port>/openspecimen/cps/{cpid}/&hellip; .
Or via the function search_collection_protocols or get_all_collection_protocols</p>
<h2 id="note">Note</h2>
<p>The optional parameters are those, which are optional for a Collection Protocol. For updating all parameters are optional,
does which are not passed to the function will stay the same as before.</p>
<h2 id="parameter">Parameter</h2>
<p>cpid : strinf or int
Unique Collection Protocol ID which is generated automatically from the System. It will be converted to a string.</p>
<p>params : string
JSON-formatted string with the parameters which should get updated. the keys which can get updated are:
title, shortTitle, code[optional], startDate[optional], endDate[optional], principalInvestigator,
coordinators[optional], irbId[optonal], anticipatedParticipantsCount[optional], activityStatus, visitNameFmt[optional],
specimenLabel[optional], derivedlabelFormat[optional], ppIdFormat[optional], cpSites,
manualPpidEnabled[optional], manualVisitNameEnabled[optional], manualSpecLabelEnabled[optional]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSON-dict</code></dt>
<dd>JSON-dict with the details of the updated Colelction Protocol or the OpenSpecimen's error message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_collection_protocol(self, cpid, params):

    &#34;&#34;&#34;Updates a existing Collection Protocol with ID ::cpid:: with the Parameters ::params::

    Updates a existing Colelction Protocol with the automatically generated OpsenSpecimen&#39;s system wide
    unique Collection Protocol ID ::cpid::, with the Parameters ::params:: which are passed to the function.
    The ID of the Collection Protocol have to be known and can for example be seen in the GUI by clicking on 
    the Collection Protocol, which has the format http(s)://&lt;host&gt;:&lt;port&gt;/openspecimen/cps/{cpid}/... .
    Or via the function search_collection_protocols or get_all_collection_protocols

    Note
    ----
    The optional parameters are those, which are optional for a Collection Protocol. For updating all parameters are optional,
    does which are not passed to the function will stay the same as before.

    Parameter
    ---------
    cpid : strinf or int
        Unique Collection Protocol ID which is generated automatically from the System. It will be converted to a string.
    
    params : string
        JSON-formatted string with the parameters which should get updated. the keys which can get updated are: 
        title, shortTitle, code[optional], startDate[optional], endDate[optional], principalInvestigator, 
        coordinators[optional], irbId[optonal], anticipatedParticipantsCount[optional], activityStatus, visitNameFmt[optional],
        specimenLabel[optional], derivedlabelFormat[optional], ppIdFormat[optional], cpSites,
        manualPpidEnabled[optional], manualVisitNameEnabled[optional], manualSpecLabelEnabled[optional]

    Returns
    -------
    JSON-dict
        JSON-dict with the details of the updated Colelction Protocol or the OpenSpecimen&#39;s error message.
    &#34;&#34;&#34;

    endpoint = &#39;/&#39; + str(cpid)
    url = self.base_url + endpoint
    payload = params
    r = self.OS_request_gen.put_request(url, payload)

    return json.loads(r.text)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="OpenSpecimenAPIconnector.os_core" href="index.html">OpenSpecimenAPIconnector.os_core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol">collection_protocol</a></code></h4>
<ul class="">
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.ausgabe" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.ausgabe">ausgabe</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.create_collection_protocol" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.create_collection_protocol">create_collection_protocol</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.delete_collection_protocol" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.delete_collection_protocol">delete_collection_protocol</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_all_collection_protocols" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_all_collection_protocols">get_all_collection_protocols</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_collection_protocol" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_collection_protocol">get_collection_protocol</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_cp_def" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_cp_def">get_cp_def</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_cp_pandas_template" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.get_cp_pandas_template">get_cp_pandas_template</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.merge_colelction_protocols" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.merge_colelction_protocols">merge_colelction_protocols</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.search_collection_protocols" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.search_collection_protocols">search_collection_protocols</a></code></li>
<li><code><a title="OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.update_collection_protocol" href="#OpenSpecimenAPIconnector.os_core.collection_protocol.collection_protocol.update_collection_protocol">update_collection_protocol</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>